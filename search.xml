<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL C++ 二维MAP查找find()函数的使用</title>
      <link href="/c-Use2dMap/"/>
      <url>/c-Use2dMap/</url>
      
        <content type="html"><![CDATA[<h1 id="放在前面"><a href="#放在前面" class="headerlink" title="放在前面"></a>放在前面</h1><p>STL中的unordered_map类若想要实现二维map可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_map</span>&lt; <span class="keyword">char</span>, <span class="built_in">string</span>&gt; &gt; Map;</span><br></pre></td></tr></table></figure><p>这样相当于是一维二维的的数据类型为char，内容为string<br>使用起来就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;B&#x27;</span>]=<span class="string">&quot;AB&quot;</span>;</span><br></pre></td></tr></table></figure><p>不过若是我们想要给定了一个key&lt;char,char&gt; 查找这个二维map是否存在该key的值要怎么写呢？</p><h1 id="查找二维map的值"><a href="#查找二维map的值" class="headerlink" title="查找二维map的值"></a>查找二维map的值</h1><p>对于一维的我们直接调用成员函数find()就可以了<br>不过对于二维的，我们可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找Map[&#x27;A&#x27;][&#x27;B&#x27;]</span></span><br><span class="line"><span class="keyword">if</span>((Map.find(<span class="string">&#x27;A&#x27;</span>)!=Map.end()||Map.end()-&gt;first==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    &amp;&amp;(Map[<span class="string">&#x27;A&#x27;</span>].find(<span class="string">&#x27;B&#x27;</span>)!=Map[<span class="string">&#x27;A&#x27;</span>].end()||Map[<span class="string">&#x27;A&#x27;</span>].end()-&gt;first==<span class="string">&#x27;B&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;exist!&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT中使用QSS将QMainWindow设置为圆角边框</title>
      <link href="/qmaindowsRadiusSetting/"/>
      <url>/qmaindowsRadiusSetting/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用QT中的QSS是一种美化可视控件非常高效的方式，QSS可以十分轻松地构建出优美的界面。</p><p>有时候我们想使用QSS来将QMainWindows界面设置为四角为圆角，但却发现无法设置，或底部背景仍是直角。</p><h1 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h1><p>我们想设置QMainWindow圆角，通常会习惯这样写qss：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QMainWindow</span>&#123;</span><br><span class="line">    <span class="comment">/* 设置圆角 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>; </span><br><span class="line">    <span class="comment">/* 设置背景颜色 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">67</span>, <span class="number">94</span>, <span class="number">134</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220713192210.png" alt="结果"></p><p>可以看到设置的背景颜色生效了但是圆角没有生效，继续尝试发现改成使用QWidget也不行</p><p>查找各种资料之后发现QMainWindow是不支持qss的radius属性的，因为他们没有了frame层。</p><p>那么我们要如何实现圆角效果呢，我们可以换个思路</p><p>观察到QMainWindow下还涵盖了<code>centralwidget</code>控件，它实际上是QWidget类的</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220713193755.png"></p><p>我们可以设置<code>centralwidget</code>的qss效果，并将QMainWindow背景隐藏<br>如下：<br>在QSS中设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QWidget</span><span class="selector-id">#centralwidget</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">67</span>, <span class="number">94</span>, <span class="number">134</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置QMainWindow背景隐藏，这里顺便设置隐藏标题栏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;setWindowFlags(Qt::FramelessWindowHint | Qt::WindowMinimizeButtonHint);</span><br><span class="line"><span class="keyword">this</span>-&gt;setAttribute(Qt::WA_TranslucentBackground);</span><br></pre></td></tr></table></figure><p>大功告成，效果如下<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220713194432.png"></p><p>这样就实现了我们想要的圆角效果，</p><p>另外如果没有centralwidget我们可以给QMainWindow手动添加一个QFrame，并使其填满整个窗口，再把所有控件都扔进这个QFrame，像上面<code>QWidget#centralwidget</code>一样设置QFrame的qss样式即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QtQSS注释导致效果失效原因</title>
      <link href="/qssCommentsInvaild/"/>
      <url>/qssCommentsInvaild/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>QSS注释某一部分之后导致后面的控件设置的QSS失效</p><p>这大概率是你嵌套注释了,QSS同CSS一样是<strong>不允许嵌套注释</strong>的</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>如下代码中<code>QWidget#centralwidget</code>已经存在部分注释</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QWidget</span>&#123;</span><br><span class="line">    <span class="comment">/* background-color: #48a5fd; */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:Microsoft Yahei,sans-serif;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QWidget</span><span class="selector-id">#centralwidget</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#c3f6ff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="comment">/* background-image: url(:/bg/QSS_IMG/720p.jpg); */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QMessageBox</span>  &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">67</span>, <span class="number">94</span>, <span class="number">134</span>);</span><br><span class="line">    <span class="comment">/* border-image: url(:/bg/QSS_IMG/720p.jpg) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们像C++那样直接注释掉<code>QWidget#centralwidget</code>全部QSS内容,变成如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QWidget</span>&#123;</span><br><span class="line">    <span class="comment">/* background-color: #48a5fd; */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:Microsoft Yahei,sans-serif;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* QWidget#centralwidget&#123;</span></span><br><span class="line"><span class="comment">    background-color: #c3f6ff;</span></span><br><span class="line"><span class="comment">    border-radius: 15px;</span></span><br><span class="line"><span class="comment">    /* background-image: url(:/bg/QSS_IMG/720p.jpg); */</span></span><br><span class="line">&#125; */</span><br><span class="line"><span class="selector-tag">QMessageBox</span>  &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">67</span>, <span class="number">94</span>, <span class="number">134</span>);</span><br><span class="line">    <span class="comment">/* border-image: url(:/bg/QSS_IMG/720p.jpg) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>QWidget#centralwidget</code>的注释存在注释嵌套,<code>/*</code>只会匹配后面遇到的第一个<code>*/</code>.这样就会导致后面的<code>&#125;*/</code>没有注释,造成后续QSS内容解析异常,解析器只解析到了<code>QWidget</code>的样式设置,后续的样式解析失败,导致失效。</p><p>要解决其实很简单,去掉要注释内容中除了最后的<code>*/</code>即可.</p><p>可以这样修改,将不需要的<code>*/</code>修改成<code>* /</code>,即中间加个空格即可,如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QWidget</span>&#123;</span><br><span class="line">    <span class="comment">/* background-color: #48a5fd; */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:Microsoft Yahei,sans-serif;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* QWidget#centralwidget&#123;</span></span><br><span class="line"><span class="comment">    background-color: #c3f6ff;</span></span><br><span class="line"><span class="comment">    border-radius: 15px;</span></span><br><span class="line"><span class="comment">    /* background-image: url(:/bg/QSS_IMG/720p.jpg); * /</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="selector-tag">QMessageBox</span>  &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">67</span>, <span class="number">94</span>, <span class="number">134</span>);</span><br><span class="line">    <span class="comment">/* border-image: url(:/bg/QSS_IMG/720p.jpg) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样注释就正常了，QSS解析也正常了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派2022新版系统首次启动SSH连接拒绝解决办法</title>
      <link href="/raspberryPiSSHdenied/"/>
      <url>/raspberryPiSSHdenied/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天树莓派4B板子到手了，跟着网上和书籍的教程下了个2022/4月份的完整版镜像烧到sd卡安装。</p><p>因为手头没有显示器micohdmi转接线，所以打算ssh连接。但跟着安装教程wifi和ssh啥的都配置了，用pi用户ssh连接总提示请求拒绝。</p><p>上stackoverflow一查原来是新版系统取消了默认用户，好家伙直接失效了全网大部分教程。</p><p>根据文档，如果你使用官方的工具Pi Imager刷入sd卡前设置了用户密码并开启了ssh，那么连接就没什么问题，用设置好的用户就行了。</p><p>但如果你是用第三方工具将镜像烧入sd卡，因为没有设置用户而且不存在默认的pi用户所以你第一次启动无法用ssh连接。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ul><li>最好的方法就是用官方的工具<a href="https://www.raspberrypi.com/software/">Pi Imager</a>重新烧录镜像到sd卡，记得设置好连接的wifi，用户，开启ssh服务。<img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/071911_nZth_4937141.png"></li><li>还有一种方法就是在boot分区下创建一个文件名为<code>userconf.txt</code>的文件，在文件里写入<code>username:encrypted-password</code>。 其中<code>username</code>是你想要的用户名，<code>encrypted-password</code>是你的想设置的密码经过加密后的值。这个值怎么得到呢？官方文档说在另一个已经装了Raspberry Pi的系统上运行<code>echo &#39;mypassword&#39; | openssl passwd -6 -stdin</code> 其中<code>mypassword</code> 是你想要设置的明文密码，运行之后得到一串字符就是加密后你的密码了。(好家伙还要用已有的系统进行加密)可以看出这种方法非常麻烦。所以大家老老实实用第一种吧。</li></ul><blockquote><p>参考来自<a href="https://stackoverflow.com/questions/71804429/raspberry-pi-ssh-access-denied">https://stackoverflow.com/questions/71804429/raspberry-pi-ssh-access-denied</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT QByteArray和QString十六进制互相转换</title>
      <link href="/qtQbytearraytoqstring/"/>
      <url>/qtQbytearraytoqstring/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用QT进行串口通信时候总会涉及到QByteArray和QString互相转换还有十六进制的问题，这里写一下大概转换的方法</p><h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><h2 id="QString-转-QByteArray"><a href="#QString-转-QByteArray" class="headerlink" title="QString 转 QByteArray"></a>QString 转 QByteArray</h2><p>以下这三种都可以，区别主要是表现的字符集范围，详细看官方注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">str</span><span class="params">(<span class="string">&quot;HelloWorld&quot;</span>)</span></span>;  </span><br><span class="line">QByteArray bytes = str.toUtf8(); </span><br><span class="line"><span class="comment">/**Returns a UTF-8 representation of the string as a QByteArray.</span></span><br><span class="line"><span class="comment">UTF-8 is a Unicode codec and can represent all characters </span></span><br><span class="line"><span class="comment">in a Unicode string like QString. **/</span></span><br><span class="line">QByteArray bytes = str.toLocal8Bit(); <span class="comment">// </span></span><br><span class="line"><span class="comment">/**Returns the local 8-bit representation of the string as a QByteArray. </span></span><br><span class="line"><span class="comment">The returned byte array is undefined if the string contains </span></span><br><span class="line"><span class="comment">characters not supported by the local 8-bit encoding.**/</span></span><br><span class="line">QByteArray bytes = str.toLatin1(); </span><br><span class="line"><span class="comment">/**Returns a Latin-1 representation of the string as a QByteArray.</span></span><br><span class="line"><span class="comment">The returned byte array is undefined if the string contains </span></span><br><span class="line"><span class="comment">non-Latin1 characters. Those characters may be suppressed </span></span><br><span class="line"><span class="comment">or replaced with a question mark.**/</span></span><br></pre></td></tr></table></figure><h2 id="QByteArray-转-QString"><a href="#QByteArray-转-QString" class="headerlink" title="QByteArray 转 QString"></a>QByteArray 转 QString</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">bytes</span><span class="params">(<span class="string">&quot;HelloWorld&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">QString str = bytes;</span><br><span class="line"><span class="comment">//注意如果bytes的二进制字节数组中存在&#x27;\0&#x27;这种在QString中被认为是结束符的符号，</span></span><br><span class="line"><span class="comment">//会使QString只获取到&#x27;\0&#x27;前的内容</span></span><br><span class="line"></span><br><span class="line">QString strbytes = QString::fromLatin1(bytes, bytes.size()); </span><br><span class="line"><span class="comment">//使用这种方式就不会存在上述问题</span></span><br><span class="line"><span class="comment">//同样也有 QString::fromUtf8() QString::toLocal8Bit()</span></span><br></pre></td></tr></table></figure><h2 id="十六进制明文QString-转-QByteArray"><a href="#十六进制明文QString-转-QByteArray" class="headerlink" title="十六进制明文QString 转 QByteArray"></a>十六进制明文QString 转 QByteArray</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">text</span><span class="params">(<span class="string">&quot;48656C6C6F576F7264&quot;</span>)</span></span>;<span class="comment">//&quot;HelloWorld&quot;</span></span><br><span class="line">QByteArray data = QByteArray::fromHex(text.toUtf8());</span><br><span class="line">qDebug() &lt;&lt; data; <span class="comment">//输出 HelloWorld</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中，hpp文件的使用</title>
      <link href="/hppfile/"/>
      <url>/hppfile/</url>
      
        <content type="html"><![CDATA[<h2 id="hpp文件"><a href="#hpp文件" class="headerlink" title="hpp文件"></a>hpp文件</h2><p>是Header plus plus的缩写，实质是将.cpp的实现代码混入.h头文件，即声明与定义（实现）都包含在同一个文件中。</p><p>该类的调用者只需要include该hpp文件即可，无需再将cpp加入到project中进行编译。</p><p>实现代码将直接编译到调用者的obj文件中，不再生成单独的obj。</p><p>采用hpp将大幅度减小project中的cpp文件数与编译次数，也不再发布烦人的lib与dll，因此非常适合用来编写公用的开源库。</p><p><strong>hpp文件与h文件的联系：</strong></p><ol><li><p>与*.h类似，hpp是C++程序的头文件</p></li><li><p>是VCL（Visual Component Library的缩写，即可视组件库）专用的头文件，已预编译</p></li><li><p>是一般模板类的头文件</p></li><li><p>一般来说，*.h里面只有声明，没有实现；而*.hpp里面既有声明也有实现，显然后者可以减小cpp的数量。</p></li></ol><h2 id="一些特征"><a href="#一些特征" class="headerlink" title="一些特征"></a>一些特征</h2><ol><li><p>是Header Plus Plus 的简写。</p></li><li><p>与*.h类似，hpp是C++程序头文件 。</p></li><li><p>是VCL 专用的头文件,已预编译。</p></li><li><p>是一般模板类的头文件。</p></li><li><p>一般来说，*.h里面只有声明，没有实现，而*.hpp里声明实现都有，后者可以减 少.cpp的数量。</p></li><li><p><em>.h里面可以有using namespace std，而</em>.hpp里则无。</p></li><li><p>*.hpp要注意的问题有：</p><ul><li>a)不可包含全局对象和全局函数</li></ul><p>由于hpp本质上是作为.h被调用者include，所以当hpp文件中存在全局对象或者全局函数，而该hpp被多个调用者include时，将在链接时导致符号重定义错误。要避免这种情况，需要去除全局对象，将全局函数封装为类的静态方法。</p><ul><li>b)类之间不可循环调用</li></ul><p>在.h和.cpp的场景中，当两个类或者多个类之间有循环调用关系时，只要预先在头文件做被调用类的声明即可，如下：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(B b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在hpp场景中，由于定义与实现都已经存在于一个文件，调用者必需明确知道被调用者的所有定义，而不能等到cpp中去编译。因此hpp中必须整理类之间调用关系，不可产生循环调用。同理，对于当两个类A和B分别定义在各自的hpp文件中，形如以下的循环调用也将导致编译错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.hpp&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(B b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//b.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.hpp&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>c)不可使用静态成员</p><p>静态成员的使用限制在于如果类含有静态成员，则在hpp中必需加入静态成员初始化代码，当该hpp被多个文档include时，将产生符号重定义错误。唯 一的例外是const static整型成员，因为在vs2003中，该类型允许在定义时初始化，如：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> intValue = <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 由于静态成员的使用是很常见的场景，无法强制清除，因此可以考虑以下几种方式（以下示例均为同一类中方法）</p><p>   一、类中仅有一个静态成员时，且仅有一个调用者时，可以通过局域静态变量模拟</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法模拟获取静态成员</span></span><br><span class="line"></span><br><span class="line"> <span class="function">someType <span class="title">getMember</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> someType <span class="title">value</span><span class="params">(xxx)</span></span>;<span class="comment">//作用域内静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二、.类中有多个方法需要调用静态成员，而且可能存在多个静态成员时，可以将每个静态成员封装一个模拟方法，供其他方法调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">someType <span class="title">getMemberA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> someType <span class="title">value</span><span class="params">(xxx)</span></span>;<span class="comment">//作用域内静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">someType <span class="title">getMemberB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> someType <span class="title">value</span><span class="params">(xxx)</span></span>;<span class="comment">//作用域内静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">accessMemberA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    someType member = getMemberA();<span class="comment">//获取静态成员</span></span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//获取两个静态成员</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">accessStaticMember</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    someType a = getMemberA();<span class="comment">//获取静态成员</span></span><br><span class="line"></span><br><span class="line">    someType b = getMemberB();</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>三、第二种方法对于大部分情况是通用的，但是当所需的静态成员过多时，编写封装方法的工作量将非常巨大，在此种情况下，建议使用Singleton模式，将被调用类定义成普通类，然后使用Singleton将其变为全局唯一的对象进行调用。</p><pre><code> 如原h+cpp下的定义如下：</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">type <span class="title">getMember</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> member;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> type member;<span class="comment">//静态成员</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 采用singleton方式，实现代码可能如下（singleton实现请自行查阅相关文档）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际实现类</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Aprovider</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">type <span class="title">getMember</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> member;</span><br><span class="line"> &#125;</span><br><span class="line">    type member;<span class="comment">//变为普通成员</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//提供给调用者的接口类</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">type <span class="title">getMember</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton&lt;AProvider&gt;::getInstance()-&gt;getMember();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>转载：<a href="http://blog.chinaunix.net/uid-24118190-id-75239.html">http://blog.chinaunix.net/uid-24118190-id-75239.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《泰坦陨落2》动态皮肤（VTF）MOD制作教程</title>
      <link href="/ttf2AnimatedSkintutorial/"/>
      <url>/ttf2AnimatedSkintutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>泰坦陨落2是由重生娱乐制作组开发一款快节奏FPS游戏，游戏由其畅快的高机动性枪战体验和独有的泰坦机甲而广受玩家好评。</p><p>本文是一篇关于如何为泰坦陨落2制作动态武器皮肤的教程。教程内容全部由本人HK560编写，感谢各位热爱泰坦陨落的玩家支持。</p><p>本教程为武器动态皮肤制作教程，其他泰坦皮肤或铁驭皮肤可参考本教程和其他文档进行类推，无论是是否动态静态的。</p><p>注意：泰坦陨落2皮肤制作有两种方式：一种是VTF方式，一种是DDS方式</p><p>简单描述差异: VTF方式能实现动态效果，可以打包为北极星MOD方便北极星启用禁用，缺点是<strong>无法使用法线贴图AO贴图等</strong>只能使用基础颜色贴图。而DDS方式只能是静态贴图，但是能够使用游戏所支持的法线贴图AO贴图发光贴图等，能再现游戏内贴图效果。两种方式打包制作复杂度类似。</p><p><strong>本文教程是动态皮肤教程，所以是VTF方式制作皮肤。</strong></p><p><strong>转载请标明原作者和原文章地址</strong></p><h1 id="制作动态皮肤的大体流程"><a href="#制作动态皮肤的大体流程" class="headerlink" title="制作动态皮肤的大体流程"></a>制作动态皮肤的大体流程</h1><p>流程简述：</p><ol><li>获取武器模型文件</li><li>获取武器模型对应贴图文件</li><li>处理模型文件</li><li>根据获得到的资源文件进行基础皮肤制作</li><li>将基础皮肤处理为动态皮肤</li><li>压缩动态皮肤文件</li><li>打包导入皮肤文件</li></ol><p><strong>动态皮肤原理：动态皮肤的贴图是由一帧帧的静态贴图组合而成，当这些贴图帧按顺序播放时候便形成了动画动态的贴图</strong></p><p>根据原理我们需要提前构思好皮肤如何制作</p><h1 id="需要的工具软件和文档"><a href="#需要的工具软件和文档" class="headerlink" title="需要的工具软件和文档"></a>需要的工具软件和文档</h1><h2 id="用于解包打包获取资源文件的工具"><a href="#用于解包打包获取资源文件的工具" class="headerlink" title="用于解包打包获取资源文件的工具"></a>用于解包打包获取资源文件的工具</h2><ul><li><strong>Titanfall VPK Tool</strong></li><li><strong>Legion v2.13</strong></li><li><strong>RSPNVPK</strong></li></ul><p>以上工具可以在我个人资源站获取：<a href="https://onedrive.hk560.top/TTF2mods/Tools">链接</a></p><blockquote><p>其中Titanfall VPK Tool可能会误报毒</p></blockquote><h2 id="用于处理模型制作动态皮肤的软件"><a href="#用于处理模型制作动态皮肤的软件" class="headerlink" title="用于处理模型制作动态皮肤的软件"></a>用于处理模型制作动态皮肤的软件</h2><p>并不是都需要，看你做皮肤用到什么</p><ul><li>Blender （处理模型</li><li>Adobe Substance 3D Painter （模型绘制贴图</li><li>Adobe Photoshop （处理动态贴图</li><li>Adobe Premiere Pro （处理动态贴图</li><li>Caesium （压缩贴图文件</li><li>Hex Editor Neo (编辑文件十六进制</li></ul><h2 id="帮助文档站点"><a href="#帮助文档站点" class="headerlink" title="帮助文档站点"></a>帮助文档站点</h2><ul><li><a href="https://noskill.gitbook.io/titanfall2/">NoSkill</a> </li></ul><h1 id="教程主体"><a href="#教程主体" class="headerlink" title="教程主体"></a>教程主体</h1><h2 id="获得武器模型文件"><a href="#获得武器模型文件" class="headerlink" title="获得武器模型文件"></a>获得武器模型文件</h2><p>既然要为武器制作皮肤，那么我们首先需要取得武器模型文件，有了模型我们才方便绘制皮肤</p><p>大部分的武器模型文件储存在这两个文件中,这两个文件是一对的</p><ul><li><code>\Titanfall2\vpk\client_mp_common.bsp.pak000_000.vpk</code></li><li><code>\Titanfall2\vpk\englishclient_mp_common.bsp.pak000_dir.vpk</code></li></ul><p>当然这个vpk文件夹下还有许多其他资源文件，详细参考Noskill里的文档</p><p>那么我们要怎么打开这两个文件呢，熟悉起源的可能就注意到这很像是起源引擎的资源文件，但用通用的起源工具是无法打开的，因此这里就用到了上面说到的<code>Titanfall VPK tool</code></p><ol><li><p>打开Titanfall VPK Tool，点击左上角File-&gt;Open<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213113209.png"></p></li><li><p>找到<code>\Titanfall2\vpk\englishclient_mp_common.bsp.pak000_dir.vpk</code>打开即可<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213113515.png"></p><blockquote><p>打开englishXXXX相当于打开了对应的clientXXXX，所以这里我们选择<code>englishclient_mp_common.bsp.pak000_dir.vpk</code>也就相当于选择打开了<code>client_mp_common.bsp.pak000_000.vpk</code>和<code>englishclient_mp_common.bsp.pak000_dir.vpk</code>这一对文件。</p></blockquote></li><li><p>打开之后就能看到vpk文件里面的内容了<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213113841.png"></p></li><li><p>我们不需要想太多，为了后续方便提取文件我们将全部文件导出为好，点击<code>Extract all</code><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213114036.png"></p><p>新建个文件架存储导出的所有文件，图中为例存储到commonFile空文件夹中<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213114245.png"></p><p> 等待导出完成点击ok，这样就得到了vpk文件中的资源文件<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213114444.png"></p></li><li><p>取得我们想要制作皮肤的武器模型位置，以car武器为例（其他武器位置请查看NoSkill的文档），模型位置在刚刚导出文件中的<code>\models\weapons\car101</code>的文件夹中，另外也请额外留意该武器模型的路径，以后我们还会用到</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213114823.png"></p><p> 其中ptpov_XXX开头的mdl文件是第一人称的武器模型，w_XXX开头的mdl文件是第三人称的武器模型，第一人称的模型肯定是最精细的，我们应该使用ptpov_XXX文件来作为模型设计皮肤。</p><p>当然并不是说w_XXX文件就没用了，后面我们仍然需要用到。<strong>因此这里需要将这两个文件都做好备份。</strong></p></li><li><p>用Legion工具来提取mdl文件中的模型至通用模型文件格式。打开我们准备好的Legion工具，打开之后先点击<code>Settings</code><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213115822.png"></p><p>按照下图进行设置，确保和你的设置无误<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213115917.png"></p><p> 设置好后关闭<code>Settings</code>窗口</p><p> 然后点击<code>Titanfall 2</code><br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213120206.png"></p><p> 显示出如图的窗口，我们将上面准备好的ptpov文件直接拖进去<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213120348.png"></p><p> 拖进去不会有任何提示，但实际没有意外的话Legion已经提取出模型文件了</p><p> 你可以在Legion程序同目录下的<code>exported_files</code>文件夹内找到导出的文件,如图例<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213120734.png"></p><p> 这个.smd文件便是我们需要的武器模型文件。至此我们得到了武器的通用模型格式文件。但为了方便后续制作皮肤我们还得处理一下该模型文件。</p></li></ol><h2 id="获取武器模型对应贴图文件"><a href="#获取武器模型对应贴图文件" class="headerlink" title="获取武器模型对应贴图文件"></a>获取武器模型对应贴图文件</h2><p>上面步骤中我们得到了武器的模型文件，但为了方便制作皮肤我们往往需要参考武器原本的贴图，那么这就需要获取游戏原本武器贴图资源文件了。</p><ol><li><p>打开legion，点击<code>Load File</code>,选择资源文件<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213130744.png"></p><p>我们要打开<code>\Titanfall2\r2\paks\Win64\common.rpak</code>该文件，里面包含了不少武器贴图文件。<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213131013.png"></p><p>打开之后legion会如图显示出该文件内的内容<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213131054.png"></p><p>我们在上方搜索框搜索想要的武器贴图名字，例如car的贴图名为car_smg<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213131200.png"></p><p>双击选中项进行导出，当Status变为Exported表示导出成功<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213131300.png"></p><p>我们一样打开legion程序同目录下的<code>exported_files</code>文件夹找到我们刚导出的内容，如图<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220213131442.png"></p><p>这些便是武器的贴图文件，包含了基础颜色贴图法线贴图AO贴图等。若不懂有什么作用请自行搜索了解，这里不再细讲。</p></li></ol><h2 id="处理模型文件"><a href="#处理模型文件" class="headerlink" title="处理模型文件"></a>处理模型文件</h2><p>我们需要对已经提取出来的.smd模型文件进行处理，方便我们后续导入到其他软件制作皮肤。</p><ol><li><p>启动Blender 新建一个常规项目<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215103955.png"></p></li><li><p>按图步骤导入我们的上面提取出的模型文件<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215104108.png"></p><p>如果你是第一次使用Blender你可能会发现你没有这个导入选项，这是因为你没有装起源引擎工具，下面演示如何下载安装该工具组</p><ol><li>打开<a href="http://steamreview.org/BlenderSourceTools/">BLENDER SOURCE TOOLS</a>该网站，点击<code>DOWNLOAD</code>按钮下载工具文件。</li><li>下载后不需要解压这个文件，回到Blender，点击 编辑-&gt;偏好设置-&gt;插件-&gt;安装 找到你下载好的工具文件安装。安装好后找到<code>Blender Source Tools</code>勾选启用。<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215105022.png"><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215105129.png"><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215105209.png"></li><li>保存设置重启Blender。这样你就能导入.smd模型文件了,回到上面的第二步。</li></ol></li><li><p>选中之前导出的模型文件，导入进blender<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215105534.png"></p><p>成功之后就能看到模型了</p><p> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215105647.png"></p><p> 右边也会显示出集合，我们可以删除掉不需要的集合比如动画光源相机之类的，只留下我们想要的模型</p><p> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215105904.png"></p></li><li><p>处理模型，一般来说为了方便绘制皮肤我们把弹夹瞄准镜之类的模型分开来比较好，好在这些模型本来就分开了，我们只需要选中对应的按G拖动就行了</p><p> 可以处理成如图</p><p> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215110415.png"></p></li><li><p>接下来我们要保存为其他通用模型格式方便我们导入另外的模型贴图绘制软件，这里导出为.obj格式</p><p> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215110601.png"></p><p> 自己随便起个名字，导出到自己想要的路径即可。<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215110958.png"></p><p> 这也就完成模型文件的处理了。可以进入绘制贴图制作皮肤环节</p><h2 id="模型皮肤贴图制作"><a href="#模型皮肤贴图制作" class="headerlink" title="模型皮肤贴图制作"></a>模型皮肤贴图制作</h2></li><li><p>打开Adobe Substance 3D Painter，新建个项目（快捷键Ctrl+N)<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215112510.png"></p><p>文件选择刚刚导出的obj文件，其他和如图设置即可</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215112626.png"></p><p>点击ok即可</p></li><li><p>新建完后应该就能看到模型了如图<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215112739.png"></p><p>右边纹理集选择对应的模型，就可以给对应的模型绘制贴图了</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215112842.png"></p><p>然后还可以导入上面我们提取出来的贴图文件应用</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215113135.png"></p><p><strong>受篇幅限制我这里不会也不可能细致讲sp(Substance 3D Painter)的功能和使用方法的，请大家自行网上搜索教程学习，这里只简单一笔带过</strong></p><blockquote><p>sp只能绘制静态的贴图，而我们要实现的动态皮肤实际上是由一帧帧的静态贴图组合而成。因此要做动态皮肤需要提前构思好皮肤如何制作，比如我大部分动态皮肤的思路都是先绘制好基础的静态贴图，然后再在静态贴图上放个视频或动画或gif，合成之后再在pr里分为一帧帧。</p></blockquote><blockquote><p>注意我们做的贴图分辨率为2048x2048即可，游戏原本贴图的分辨率也是这个</p></blockquote><p>如图，当我们绘制好基础皮肤后我们需要导出贴图</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215114256.png"></p><p>有两种方式，一种直接sp导出，还有一种经由sp导出到pr，再在pr处理好后导出，我们最终目标都是获取静态贴图。</p><ul><li><p>sp导出贴图：</p><p>  <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215114542.png"></p><p>  然后如图设置，选择你要导出的贴图，因为vtf制作的皮肤只有basecolor贴图生效，所以我们只需要导出basecolor贴图就行了，点击导出</p><p>  <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215114718.png"></p><p>  导出成功即可得到贴图文件</p><p>  <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215114938.png"></p></li><li><p>实际上为了更好的效果我们还需要经过ps和pr处理，所以大部分情况会选择导出到ps先</p><p>  如图导出至ps，这要求你已经装好了ps而且不是绿色版那种</p><p>  <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215114502.png"></p><p>  会提示你执行脚本，允许即可，然后就可以导入进ps了。按照你自己需求想法修改皮肤贴图</p><p>  <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215120204.png"></p><p>  <strong>推荐在使用sp绘制贴图时候就做好遮罩图层，方便后面加上一些视频美观不会那么突兀，sp导出到ps也是同样会分图层的，然后ps在讲贴图文件保存成psd，psd文件再导入到pr里也是可以分图层的，这样在pr里就会十分方便了。</strong></p></li></ul><p> 其实到这里如果你只是做静态皮肤这里就已经完成了皮肤制作了。可以进入皮肤处理打包环节了。不过我们这里是做动态皮肤所以当然还有很多东西要做咯</p></li></ol><h2 id="处理为动态皮肤贴图"><a href="#处理为动态皮肤贴图" class="headerlink" title="处理为动态皮肤贴图"></a>处理为动态皮肤贴图</h2><p>前面其实已经简单提到过了动态皮肤的原理，这里细致讲讲吧：</p><p>类同于起源引擎动画贴图的制作，动画贴图就是由很多张图片（也就是帧）组成，按顺序播放之后就会形成动画动态的效果，播放是循环的，因此还需要做好首尾连贯拼接处理。在起源引擎中可以将这一系列的帧打包为vtf文件。如果是静态皮肤只有一张贴图便足够，但动画贴图就需要很多张贴图来组成帧，比如若想要播放贴图动画3秒，一秒30帧，那么就一共需要90帧贴图。</p><p>我们的思路很简单，先把本是一张图片的贴图做成视频，视频的播放效果便是我们想要的动态效果，做好首尾循环处理，最后将视频导出拆分一帧帧，打包为vtf文件，塞到游戏里。</p><p>如果很难理解上面说的话，可以参考我以前做的皮肤的 <a href="https://www.bilibili.com/video/BV1iy4y1g7kP">R201动态皮肤演示视频</a> 理解。p1是展示，p2是贴图做成视频的样子，都看一下就应该能理解了。尤其是p2一定要看一下!</p><p>接下来用我car动态皮肤的制作流程作为示例吧，接下来会讲的稍微简单一些，因为理解了原理就很好做动态皮肤了，可以根据自己的想法来不需要和我一样</p><p>使用Adobe Premiere Pro新建个项目，导入我们上面从ps导出保存的psd贴图文件作为素材</p><p>然后处理一下加入一些动画素材或者视频素材，比如我的斯卡蒂系列皮肤就会加入live2d的视频素材做成动画</p><p>   <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215180905.png"></p><p>   像上图那样活用轨道和轨道遮罩键还有pr里面带的转场效果，就能做出很不错的效果</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/%E5%8A%A8%E7%94%BB1.gif"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/%E5%8A%A8%E7%94%BB2.gif"></p><p> 好跳过制作的详细步骤，我们继续讲导出了。</p><p>导出设置如图，关键的几个设置是：</p><p>要设置格式为JPEG 然后保证分辨率一致，还有就是<strong>帧数</strong> 帧数太高的话会导致帧画面太多，贴图文件体积大，我们所做的皮肤文件体积是有上限的，基本要保证最后所有帧图片加起来的体积不超过300MB，单个vtf文件体积不能超过1GB，体积大小取决于总帧数，一般来说保证总共帧数不超过300帧为好。我个人偏向于每秒30帧25帧这样。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215183831.png"></p><p>导出渲染完后你就会得到一堆序列图片帧了，如图</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215184459.png"></p><p>注意文件命名要按帧顺序从小到大来，不然之后导入vtf文件顺序错乱的话会导致动画播放顺序错乱。</p><p>然后你就会发现每张图片都几乎要3~5MB，那么多张图片加起来总体积肯定是太大了不能打包。那么要怎么办，接下来就是得进行压缩了。</p><h2 id="压缩皮肤贴图"><a href="#压缩皮肤贴图" class="headerlink" title="压缩皮肤贴图"></a>压缩皮肤贴图</h2><p>我们可以使用一些压缩图片的方法牺牲一点质量获取更少的体积。我用了很多压缩图片的方法工具，最后还是发现使用<code>Caesium</code> 这个软件好。综合考虑压缩耗时体积质量应该是比较好的这个软件。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220215185120.png"></p><p>一般来说品质设置成90就可以了，觉得不满意的话可以再自己调调。设定好导出路径之类的就可以压缩了。</p><p>压缩完之后我们就得到了体积较小的皮肤文件，然后就可以进入下一步了。</p><h2 id="打包使用皮肤文件"><a href="#打包使用皮肤文件" class="headerlink" title="打包使用皮肤文件"></a>打包使用皮肤文件</h2><p>这一步中的操作会比较复杂，但跟着教程走应该没什么问题</p><h3 id="生成vtf文件"><a href="#生成vtf文件" class="headerlink" title="生成vtf文件"></a>生成vtf文件</h3><p>首先我们需要将上面做好的皮肤贴图打包成vtf文件</p><ol><li><p>打开VTFEdit，根据系统是多少位的启动对应的版本</p></li><li><p>按顺序点击File-&gt;Import<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219101852.png"></p></li><li><p>弹出文件选择界面，找到我们压缩好的皮肤贴图文件，选中全部贴图文件，Ctrl+A全选，点击打开<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219102215.png"></p></li><li><p>之后会弹出导入设置页面，不懂的话根据我下图的设置来即可</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219102618.png"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219102645.png"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219102707.png"></p><p>点击ok即可开始导入</p></li><li><p>然后你就会发现程序没有响应，<strong>这是正常的</strong>，VTFEdit正在处理皮肤文件，我们不需要其他操作，等待它导入完成就行。</p><p> 这个过程的时间是很长的，期间还会占用大量内存空间。不同贴图数量体积分辨率花费时间不同，比如我这270帧图片导入往往要花上20分钟多。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219103007.png"></p></li><li><p>导入完成之后应该就可以从右边的界面预览到贴图了。<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219112154.png"></p><p>点击Play 能预览播放，当然它这里播放的帧数是慢点的，能动就行。</p></li><li><p>保存vtf文件，点击File-&gt;Save as<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219112505.png"></p><p>自己随便起个名字，保存到自己想要的路径，这样就打包好vtf文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219112653.png"></p><p>保存好这个vtf文件，多备份几个，免得不小心删除了重新导入又要花费很长时间。</p><p>我们后续步骤会再用到这个文件</p></li></ol><h3 id="编写vmt文件"><a href="#编写vmt文件" class="headerlink" title="编写vmt文件"></a>编写vmt文件</h3><p>接下来编写vmt文件，新建个记事本txt文件，修改后缀名为.vmt,然后用编辑器打开，往里面写如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;basic&quot;</span><br><span class="line">&#123;</span><br><span class="line">&quot;$surfaceprop&quot; &quot;metal&quot;</span><br><span class="line">&quot;$basetexture&quot; &quot;models\XXX&quot; &#x2F;&#x2F;贴图路径</span><br><span class="line"></span><br><span class="line">&quot;Proxies&quot;</span><br><span class="line">&#123;</span><br><span class="line">AnimatedTexture</span><br><span class="line">&#123;</span><br><span class="line">animatedTextureVar $basetexture</span><br><span class="line">animatedTextureFrameNumVar $frame</span><br><span class="line">animatedTextureFrameRate 30  &#x2F;&#x2F;每秒帧数</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中这个 贴图路径 <code>&quot;$basetexture&quot;</code>是指我们上面解包englishcilent文件里的路径，后面会回来详细介绍。先不用急，继续按顺序阅读。</p><h3 id="修改mdl文件"><a href="#修改mdl文件" class="headerlink" title="修改mdl文件"></a>修改mdl文件</h3><p>vtf文件弄好后我们需要修改游戏武器模型的mdl文件的十六进制，让它指向我们的皮肤文件</p><p>还记得我们上面用到的两个mdl文件吗，这里就又要用上了。先拷贝一份出来，用于接下来的修改。继续用car的来举例演示。</p><ol><li><p>用 Hex Editor Neo 打开 ptpov_XXX.mdl 和 w_XXX.mdl文件<br> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219120036.png"></p></li><li><p>使用Ctrl + F 搜索”models” 分别在两个mdl文件中，找到形如图中的位置，这里以ptpov_XXX.mdl文件举例<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219120317.png"></p></li><li><p>注意图中划线的部分，他们都指的是在我们解包englishclient的文件中的路径，你可以理解为这个路径就是贴图文件的路径</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220219120545.png"></p><p> 红色划线：<code>.models\weapons_r2\car_smg\CAR_smg</code>，指的是原厂贴图的路径</p><p> 黑色划线：<code>.models\weapons_r2\car_smg\CAR_smg_skin_31</code>，指的是除开原厂贴图和精英皮肤的其他皮肤贴图路口</p><p> 如果你按照这个路径去解包出的文件里面找是找不到的，毕竟这是重生魔改过的起源。很多地方还是不一样的。</p></li><li><p>为了使用我们做的自定义皮肤，我们需要修改这划线的部分，使其指向我们的vmt文件。根据你的需求，如果想要替换原厂皮肤就修改红色划线部分的路径，如果想要修改除开原厂贴图和精英皮肤的其他皮肤就修改黑色划线的部分。当然你也可以两个都改。改路径有个非常重要的要求，<strong>要求保证路径长度和原来一样</strong></p><p> 比如原路径为<code>.models\weapons_r2\car_smg\CAR_smg</code>，一共33个字符长度</p><p> 那我修改后的路径可以为<code>.models\weapons_r2\car_smg\car.vmt</code>，vmt文件命名为CAR.vmt</p><p> 或 <code>.models\weapons_r2\car_smg\abc.vmt</code>，vmt文件命名为abc.vmt</p><p> 或 <code>.models\weapons_r2\car\Skin\cd.vmt</code>，vmt文件命名为cd.vmt</p><p> 要求就是总长度和原来的一样，指向vmt文件，否则会破环mdl文件游戏无法识别。</p><p> 在这里我举例只修改原厂皮肤的情况，那我要修改红色划线部分内容，可以修改为<code>.models\weapons_r2\car_smg\car.vmt</code></p><p> <img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220220124146.png"></p><p> 红色字体部分就是修改过的部分。</p><p> <strong>注意注意注意！！ptpov_XXX.mdl 和 w_XXX.mdl两个文件都要进行同样的修改</strong> </p><blockquote><p>ptpov_XXX.mdl文件是第一人称的武器模型 ，w_XXX.mdl文件是第三人称的模型</p></blockquote><p>这样才能让第一人称的武器模型和第三人称的武器模型都正常显示导入的mod皮肤。</p><p>保存好这两个修改好的mdl文件，接下来我们还需要用上。</p></li></ol><h3 id="按照路径配置皮肤文件布局"><a href="#按照路径配置皮肤文件布局" class="headerlink" title="按照路径配置皮肤文件布局"></a>按照路径配置皮肤文件布局</h3><p>通过上面的步骤设置了皮肤vmt文件的路径，请记住你设置的文件路径，接下来需要根据设置的路径放置皮肤文件。</p><!-- 上面的例子中我们设置的路径为`.models\weapons_r2\car_smg\CAR.vmt`,我们就按这个路径为例子继续讲解。 --><p>我们接下来要按照给定的文件布局格式放置皮肤文件，以方便导入打包到原本的游戏文件。</p><ol><li><p>新建一个文件夹方便存放文件。在这个文件夹里面按照以下给定的格式新建文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- 你新建的文件夹名</span><br><span class="line">   |-- materials</span><br><span class="line">   |-- models</span><br></pre></td></tr></table></figure><p>肯定有人好奇会问为什么要这样设置文件夹布局，还记得之前解包vpk文件后的文件布局么，我们这里所做的就是配置好一个与原来vpk内文件布局相同的布局，好让之后打包时能够按照文件布局替换对应的文件。</p></li><li><p>按照你在取出的武器模型mdl文件时得到的<a href="#%E8%8E%B7%E5%BE%97%E6%AD%A6%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6">路径</a>，放置你修改好后的mdl文件，变成类似下面的文件布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|-- 你新建的文件夹名</span><br><span class="line">   |-- materials</span><br><span class="line">   |-- models</span><br><span class="line">       |-- weapons</span><br><span class="line">            |-- car101</span><br><span class="line">               |-- ptpov_car101.mdl</span><br><span class="line">               |-- w_car101.mdl</span><br></pre></td></tr></table></figure></li><li><p>按照你上面编辑mdl文件时设置的<a href="#%E4%BF%AE%E6%94%B9mdl%E6%96%87%E4%BB%B6">路径</a>，放置你编写的vmt文件，变成类似下面的文件布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|-- 你新建的文件夹名</span><br><span class="line">   |-- materials</span><br><span class="line">   |   |-- models</span><br><span class="line">   |       |-- weapons_r2</span><br><span class="line">   |           |-- car_smg</span><br><span class="line">   |               |-- car.vmt</span><br><span class="line">   |-- models</span><br><span class="line">       |-- weapons</span><br><span class="line">            |-- car101</span><br><span class="line">               |-- ptpov_car101.mdl</span><br><span class="line">               |-- w_car101.mdl</span><br></pre></td></tr></table></figure></li><li><p>把<a href="#%E7%94%9F%E6%88%90vtf%E6%96%87%E4%BB%B6">上面</a>生成的vtf文件也放进来，放在.vmt文件同目录下为好，如下面所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|-- 你新建的文件夹名</span><br><span class="line">   |-- materials</span><br><span class="line">   |   |-- models</span><br><span class="line">   |       |-- weapons_r2</span><br><span class="line">   |           |-- car_smg</span><br><span class="line">   |               |-- car.vmt</span><br><span class="line">   |               |-- car_base.vtf</span><br><span class="line">   |-- models</span><br><span class="line">       |-- weapons</span><br><span class="line">            |-- car101</span><br><span class="line">               |-- ptpov_car101.mdl</span><br><span class="line">               |-- w_car101.mdl</span><br></pre></td></tr></table></figure></li><li><p>我们现在已经把模型文件和皮肤文件都放好了，需要再编写vmt文件重新设置一下贴图路径，打开vmt文件修改：</p><p>注意到这一行参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$basetexture&quot; &quot;models\XXX&quot; &#x2F;&#x2F;贴图路径</span><br></pre></td></tr></table></figure><p>我们要使其指向我们的vtf皮肤文件，那么这个路径就是需要修改。更改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$basetexture&quot; &quot;models\weapons_r2\car_smg\car_base&quot; &#x2F;&#x2F;贴图路径</span><br></pre></td></tr></table></figure><p>路径是根据我们上面的文件布局得到的，注意路径前面不需要加上<code>materials\</code>，且指向的vtf文件不需要加上扩展名</p><p>修改好后保存。</p></li></ol><p>这样一来皮肤文件就弄好了。</p><p><strong>接下来我们有两种方式打包使用皮肤，各有优缺点</strong></p><ul><li>方式1 适用于原版游戏，多人单人都能正常用，装了北极星客户端也能用，缺点就是每次装多个皮肤的话都得每个皮肤一起再打包，使用者需要自己打包，很麻烦，而且皮肤效果会有出入，偏白。</li><li>方式2 只适用于安装了北极星客户端下，只有北极星游玩下才会生效，优点是皮肤文件是单独打包的，非常方便管理，使用者只需要复制粘贴就可以了，不用直接删除就行。</li></ul><h3 id="（方式1）使用RSPNVPK打包皮肤文件并安装使用"><a href="#（方式1）使用RSPNVPK打包皮肤文件并安装使用" class="headerlink" title="（方式1）使用RSPNVPK打包皮肤文件并安装使用"></a>（方式1）使用RSPNVPK打包皮肤文件并安装使用</h3><p>这种情况下使用者需要完整执行下面的步骤</p><ol><li><p>解压我们下载好的RSPNVPK</p></li><li><p>从游戏目录的vpk文件夹里复制一份<code>englishclient_mp_common.bsp.pak000_dir.vpk</code>文件到解压好的RSPNVPK根目录下，并创建一个同名的文件夹(不包括”.vpk”) </p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316163855.png"></p></li><li><p>打开englishclient_mp_common.bsp.pak000_dir文件夹，把我们的上面弄好的皮肤mod文件放进去，</p><p>注意不是直接你上面皮肤文件夹直接丢进去，而是把你文件夹里的model文件夹和materials文件夹放进去，文件布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|-- englishclient_mp_common.bsp.pak000_dir</span><br><span class="line">            |-- materials</span><br><span class="line">            |   |-- models</span><br><span class="line">            |       |-- weapons_r2</span><br><span class="line">            |           |-- car_smg</span><br><span class="line">            |               |-- car.vmt</span><br><span class="line">            |               |-- car_base.vtf</span><br><span class="line">            |-- models</span><br><span class="line">               |-- weapons</span><br><span class="line">                     |-- car101</span><br><span class="line">                        |-- ptpov_car101.mdl</span><br><span class="line">                        |-- w_car101.mdl</span><br></pre></td></tr></table></figure></li><li><p>回到RSPNVPK, 拖动<code>englishclient_mp_common.bsp.pak000_dir.vpk</code>文件到<code>RSPNVPK.exe</code> 释放打开</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/1621skin.gif"></p></li></ol><ol start="5"><li><p>如图所示，程序会自动读取到皮肤文件，</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316165921.png"></p><p>此时输入y并回车可以进行备份，并进行打包</p></li><li><p>等待程序显示如图提示完成后，按回车结束即可。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316170026.png"></p></li><li><p>此时RSPNVPK下便会重新生成两个vpk文件</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316170158.png"></p><p>这两个文件就是我们打包好的，包含皮肤mod的vpk文件</p></li></ol><p>接下来就很简单了，把上面生成的两个文件覆盖到游戏原来的vpk文件夹即可，路径<code>Titanfall2\vpk</code></p><p>(注意备份！！！)</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316170727.png"></p><p>大功告成，然后启动游戏就可以看到皮肤效果啦！</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316170903.png"></p><h3 id="（方式2，作为北极星模组）使用TitanfallVPK打包皮肤成为北极星mod"><a href="#（方式2，作为北极星模组）使用TitanfallVPK打包皮肤成为北极星mod" class="headerlink" title="（方式2，作为北极星模组）使用TitanfallVPK打包皮肤成为北极星mod"></a>（方式2，作为北极星模组）使用TitanfallVPK打包皮肤成为北极星mod</h3><p>我们需要再次用到Titanfall VPK Tool 这个工具，用其自带的功能直接打包皮肤文件为独立的vpk</p><ol><li><p>打开Titanfall VPK Tool，按如图点击<code>repacker</code></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316172436.png"></p></li><li><p>弹出如图的对话框，第一个红框设置要打包文件夹路径，第二个红框设置打包导出vpk文件的路径</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316173712.png"></p><p>然后点击build vpk即可开始打包</p><p>第一个红框选的文件夹就是我们<a href="#%E6%8C%89%E7%85%A7%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE%E7%9A%AE%E8%82%A4%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80">上面配置好的皮肤文件</a>, 为了方便理解我这边再给大家列出我图中选中的皮肤文件夹布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|-- skadiCARNFV</span><br><span class="line">   |-- materials</span><br><span class="line">   |   |-- models</span><br><span class="line">   |       |-- weapons_r2</span><br><span class="line">   |           |-- car_smg</span><br><span class="line">   |               |-- car_base.vtf</span><br><span class="line">   |               |-- car.vmt</span><br><span class="line">   |-- models</span><br><span class="line">      |-- weapons</span><br><span class="line">            |-- car101</span><br><span class="line">               |-- ptpov_car101.mdl</span><br><span class="line">               |-- w_car101.mdl</span><br></pre></td></tr></table></figure></li><li><p>如图提示打包完成后，我们便可以在设置的导出路径中得到打包好的两个vpk文件</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316174323.png"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316174439.png"></p></li><li><p>接下来我们需要给这两个文件重新命名</p><p>注意不要弄错了</p><ul><li>不以“_dir.vpk”结尾的文件命名为<code>client_mp_common.bsp.pak000_000.vpk</code></li><li>以“_dir.vpk”结尾的文件命名为<code>englishclient_mp_common.bsp.pak000_dir.vpk</code></li></ul><p>即变成</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316174850.png"></p><p>这样作为皮肤文件就打包好了，但是我们要把它变成北极星能识别的mod的话需要接下来的几个操作。</p></li><li><p>我们需要按照北极星的要求格式制作个北极星mod</p><ol><li><p>新建个文件夹，文件名格式推荐为 <code>作者.mod名字</code></p><p>比如我的car皮肤mod，可以把文件夹名字命名为 <code>HK560.CarSkadiAnimatedSkinFV</code></p></li><li><p>然后在这个文件夹里创建一个<code>mod.json</code> 文件，并打开编辑</p><p>写入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;Name&quot; : &quot;CAR Skadi Animated Skin Full Version 0.1&quot;,</span><br><span class="line">&quot;Description&quot; : &quot;Made by HK560.&quot;,</span><br><span class="line">&quot;Version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">&quot;LoadPriority&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>&quot;Name&quot;</code>后面的参数是你的mod的名字，可以自己改。<code>&quot;Description&quot;</code>是描述，<code>&quot;Version&quot;</code>是mod的版本号，<code>&quot;LoadPriority&quot;</code>是mod加载优先级</p></li></ol><p>除了<code>&quot;LoadPriority&quot;</code>最好不要改以外，其他你可以按照自己想法改，注意不支持中文！</p><p>写好后保存。</p></li></ol><blockquote><p>附：北极星mod文档可以查看<a href="https://r2northstar.readthedocs.io/en/latest/guides/publishing.html">这里</a></p></blockquote><ol start="3"><li>然后再在这个文件夹下新建一个文件夹，文件夹名为<code>vpk</code>, 把我们上面打包好的那两个vpk文件丢进去，形成如下的文件布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- HK560.CarSkadiAnimatedSkinFV</span><br><span class="line">    |-- mod.json</span><br><span class="line">    |-- vpk</span><br><span class="line">        |-- client_mp_common.bsp.pak000_000.vpk</span><br><span class="line">        |-- englishclient_mp_common.bsp.pak000_dir.vpk</span><br></pre></td></tr></table></figure>这样就可以了，这整个文件夹就是一个符合北极星要求的mod。分享给别人的话也只需要打包这整个文件夹就行了。</li></ol><h3 id="（方式2，作为北极星模组）安装使用打包为北极星mod的皮肤文件"><a href="#（方式2，作为北极星模组）安装使用打包为北极星mod的皮肤文件" class="headerlink" title="（方式2，作为北极星模组）安装使用打包为北极星mod的皮肤文件"></a>（方式2，作为北极星模组）安装使用打包为北极星mod的皮肤文件</h3><p>很简单，确保你的游戏已经安装好了北极星客户端，打开游戏根目录该路径<code>\Titanfall2\R2Northstar\mods</code></p><p>在这个mods文件夹下存放着北极星官方的模组文件，也可以存放其他符合北极星mod格式的模组文件</p><p>把我们上面弄好的皮肤mod文件夹放进去即可</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316181101.png"></p><p>（我这里mods文件夹还装了很多其他模组，不用在意）</p><p>然后正常启动北极星即可！正常的话你可以在北极星<code>模组mods</code>菜单里看到你装的mod。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316181342.png"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20220316181454.png"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/3213skin.gif"></p><p>到此教程结束！</p><h1 id="后言补充"><a href="#后言补充" class="headerlink" title="后言补充"></a>后言补充</h1><p>这篇教程断断续续写了好久，也不知道写的能不能让大家看懂，有不懂的地方可以留言评论，我尽量解答。</p><p>真的非常感激国内外那些为泰坦陨落2社区和mod社区做出贡献的大牛们，你们的付出为这个游戏这个社区再次增加了活力，由衷感谢你们！</p><p>越发了解大牛们对泰坦陨落2的研究越是感受到惊讶震撼。尤其是北极星项目的诞生，更是让我感受到了泰坦陨落社区独有的魅力和激情，这在很多其他游戏非官方项目都很难看到的。玩家们凭借技术和热情对这个游戏进行“重铸”。我也为自己是北极星CN项目人员之一感到深深的自豪。</p><p>从16年到现在，泰坦陨落2陪伴了我整个高中，到现在大学，毫无疑问我是真正热爱着这个游戏。我也希望用自己的知识和力量，为这个游戏社区贡献出自己一份力量，留下自己的痕迹。希望泰坦陨落这个游戏能有更多人发现，有更多人从这个游戏中有所收获！</p><p><strong>附：</strong></p><ul><li><a href="https://space.bilibili.com/7342356/">个人往期作品在对应视频可下载</a></li><li><a href="https://github.com/R2Northstar">北极星项目NorthStar</a></li><li><a href="https://github.com/R2NorthstarCN">北极星CN项目NorthStarCN</a></li><li>个人泰坦陨落2交流群：910232624</li><li>泰坦陨落2 皮肤MOD交流群：901265630</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NorthStarCN】 一个适用于泰坦陨落2的MOD框架</title>
      <link href="/NorthStarCN-Index/"/>
      <url>/NorthStarCN-Index/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-NorthStarCN-北极星CN-？"><a href="#什么是-NorthStarCN-北极星CN-？" class="headerlink" title="什么是 NorthStarCN 北极星CN ？"></a>什么是 NorthStarCN 北极星CN ？</h1><p><code>NorthStar</code> 是一个MOD和MOD框架，它允许玩家用户使用脚本架设他们自己的泰坦陨落2客制化服务器并自定义内容,也能够架设 vanilla 内容。对于普通玩家而言，使用NorthStar能够游玩由NorthStar架设的服务器房间，不经过官方服务器。</p><p><code>NorthStarCN</code> 则是基于原版NorthStar，进行本地化修改，修改了MasterServer并进行了部分汉化，使得在中国大陆环境下能更流畅使用NorthStar框架并进行多人联机，并提供相关可使用的MOD。该项目由国内泰坦陨落粉丝玩家维护。</p><p>NorthStar 和 NorthStarCN 都属于早期项目，仍有许多地方需要完善，如果您遇到任何问题欢迎积极交流。</p><p>我们由衷感谢感激原作者为泰坦陨落2社区贡献和付出，本项目遵守MIT协议。</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><ol><li>首先你需要下载NorthStarCN的客户端并安装，请访问<a href="https://github.com/R2NorthstarCN/R2NorthstarCN_Launcher">发布仓库</a>下载</li><li>将下载下来的客户端压缩包的所有文件解压到泰坦陨落2游戏的根目录</li><li>启动并登陆Origin完毕后，点击运行游戏根目录下的NorthstarLauncher.exe即可启动</li></ol><hr><h1 id="查看我们的Wiki以获得相关信息"><a href="#查看我们的Wiki以获得相关信息" class="headerlink" title="查看我们的Wiki以获得相关信息"></a>查看我们的<a href="https://github.com/R2NorthstarCN/NorthStarCN_WIKI/wiki">Wiki</a>以获得相关信息</h1><h2 id="查看快速帮助文档以快速配置使用NorthStarCN"><a href="#查看快速帮助文档以快速配置使用NorthStarCN" class="headerlink" title="查看快速帮助文档以快速配置使用NorthStarCN"></a>查看<a href="https://github.com/R2NorthstarCN/NorthStarCN_WIKI/wiki/%E5%BF%AB%E9%80%9F%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3">快速帮助文档</a>以快速配置使用NorthStarCN</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><strong>公开QQ交流群：660908653</strong></p><p>如果你想要下载NorthStarCN客户端请点击<a href="https://github.com/R2NorthstarCN/R2NorthstarCN_Launcher/releases">这里</a></p><p>如果你想要查看NorthStar原版仓库请点击<a href="https://github.com/R2Northstar/Northstar">这里</a></p><p>现不接受任何有偿帮助且本项目无任何收费项目注意欺骗</p><p><strong>更多信息正在完善…</strong></p><hr><p>由衷感谢 NorthStar 原开发者：</p><ul><li><a href="https://github.com/BobTheBob9">BobTheBob</a></li><li>….</li></ul><p>为 NorthStarCN 维护贡献者:</p><ul><li>wolf109909</li><li>AIALRA</li><li>panduola</li><li>HK560 </li><li>bilibili-XGY4N</li><li>IzayoiPADSakuya</li><li>….</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《代码整洁之道》阅读笔记</title>
      <link href="/CleanCodeReadingNotes/"/>
      <url>/CleanCodeReadingNotes/</url>
      
        <content type="html"><![CDATA[<h2 id="代码整洁？"><a href="#代码整洁？" class="headerlink" title="代码整洁？"></a>代码整洁？</h2><ul><li>代码永远存在，无论软件行业发展，代码永远是各种工具的基石地基，没有代码这些东西工具也不会存在，无代码运动就是个笑话</li><li>糟糕的代码会给项目发展逐渐显现弊端，混乱增加，生产力下降，最后趋于零，这是非常可怕的。</li><li>花时间保持代码整洁不但有关效率，还有关生存。整洁你的代码，保护你的饭碗。</li><li>多数经理想要好代码，他们想要知道代码实情，所以不应当羞于高数项目进展实情</li><li>写出整洁的代码是困难的，需要技巧和不断练习</li><li>整洁代码读起来是愉悦的，糟糕的代码会引发混乱，别人修改往往会越来越乱</li><li>代码应当讲述事实，不引人猜测，便于其他人增加修改</li><li>如何整洁你的代码，不如说是如何在意你的代码</li><li>不要重复代码，只做一件事，表达力，小规模抽象</li></ul><h2 id="名字要起的有意义"><a href="#名字要起的有意义" class="headerlink" title="名字要起的有意义"></a>名字要起的有意义</h2><ul><li>变量，函数，类的名字就应该能解释大部分的东西，备注都是额外的，能做到不需要额外备注就是最好的</li><li>避免取容易引发歧义猜测的名字，比如一些专有名字，大家耳熟能详但在代码中缺失另一种含义的名字</li><li>accountList 除非你是真的用List类才这样写。否则还是写成AccountGroup吧</li><li>太过相似的变量名也不合适，应该做容易区分的，尤其是“I”“l” 还有“O”“0”</li><li>取a1，a2，这种名字没有目的叫人恶心</li><li>ProductData和ProductInfo这种也是应该避免的，因为两者含义相同，是废话</li><li>名字中带变量名是废话，String类起一个NameString名字纯属废话，除非你真的指明了该名字含义下确实有不同类型</li><li>多从读者出发，想想读者会怎样理解猜测</li><li>取一些容易读出来的名字，别在乎你那自造词了，modymdhms-&gt;modificationTimestamp</li><li>使用好搜索的名字，缩写名字不一定是好习惯，会造成搜索困难</li><li>避免使用编码</li><li>前缀没有必要了</li><li>类名应该用名词或名词短语</li><li>方法名应该是动词或动词短语，get，set，is这种前缀</li><li>不要用双关语，遵循一词一意</li><li>取专业领域的技术名称会靠谱很多</li><li>问题领域的命名就用问题领域的名称</li><li>如果很难分清某个单独放置在某处的变量，该变量名称最好加上前缀</li><li>也别太滥用没有意义的前缀，给自动补全添堵，前缀应该用在难以区分辨别的时候</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数应该尽量短小</li><li>一个函数应该只做一件事，只在一个对象层进行操作</li><li>让代码拥有自顶向下的阅读顺序</li><li>使用描述性的名称，命名方式要保持一致</li><li>函数参数越少越好</li><li>函数参数多就要考虑封装成类了 </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hexo博客上使用自定义Live2D</title>
      <link href="/HowDoesHexoBlogUseLive2D/"/>
      <url>/HowDoesHexoBlogUseLive2D/</url>
      
        <content type="html"><![CDATA[<h1 id="放在前面"><a href="#放在前面" class="headerlink" title="放在前面"></a>放在前面</h1><p>之前看到有很多人用hexo博客左下角右下角总有个live2d，自己也稍微研究了一下，发现用起来还是蛮简单的，作者提供了几个live2d模型的包，但其实我们是可以使用其他的自定义的live2d模型</p><h1 id="安装使用live2d，并配置自定义live2d模型"><a href="#安装使用live2d，并配置自定义live2d模型" class="headerlink" title="安装使用live2d，并配置自定义live2d模型"></a>安装使用live2d，并配置自定义live2d模型</h1><ol><li><p>首先安装 hexo-helper-live2d <a href="https://github.com/EYHN/hexo-helper-live2d">仓库链接</a> 官方文档写了怎么安装配置了，按照步骤来即可。不同hexo主题应该是不受影响的。</p></li><li><p>配置模型,官方文档里写了需要在博客根目录创建一个<code>live2d_models</code>模型文件夹，然后你的模型文件要放在一个文件夹内，再把这个文件夹放到<code>live2d_models</code>文件夹下面<br>文件目录示例：<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211211131148.png" alt="博客根目录"><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211211131229.png" alt="live2d_models文件夹目录"><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211211131358.png" alt="hk416child文件夹目录"></p></li><li><p>使用自定义live2d模型，首先确保你的模型文件是旧版的live2d，新版好像是不兼容的。<br>然后将你的模型json文件改名为<code>XXX.model.json</code>,<code>XXX</code>为模型名字，你可以自己设置自己想要的名字。然后将整个模型文件夹的名字也改为<code>XXX</code> 把这个文件夹放到<code>live2d_models</code>。 要使用这个文件夹就在<code>_config.yml</code>的live2d配置 live2d.model.use 配置为<code>XXX</code> ,就如下图一样<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211211145937.png" alt="config配置"><br>然后就<code>hexo clean</code> <code>hexo g</code>即可。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>战地风云2042艺术设定集原生轨音乐领取下载链接</title>
      <link href="/bf2042downloadArtbookOST/"/>
      <url>/bf2042downloadArtbookOST/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说起来我其实也算是个战地系列粉丝了，bf3开始玩的，一直很喜欢运河，这次运河回来了，就没忍住买了个终极版。<br>不过这个终极版说送设定集和OST，找了好久没找到，最后终于在reddit上看到有人发了链接</p><h1 id="BF2042设定集和OST领取方法"><a href="#BF2042设定集和OST领取方法" class="headerlink" title="BF2042设定集和OST领取方法"></a>BF2042设定集和OST领取方法</h1><h2 id="1-进入领取地址"><a href="#1-进入领取地址" class="headerlink" title="1.进入领取地址"></a>1.进入<a href="https://www.ea.com/en-gb/games/battlefield/battlefield-2042/media/ultimate-edition-benefits">领取地址</a></h2><h2 id="2-点击sign登陆ea账号"><a href="#2-点击sign登陆ea账号" class="headerlink" title="2.点击sign登陆ea账号"></a>2.点击sign登陆ea账号</h2><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211127204227.png" alt="点击sign登陆"></p><h2 id="3-下载"><a href="#3-下载" class="headerlink" title="3.下载"></a>3.下载</h2><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211127204151.png" alt="下载设定集"><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211127204646.png" alt="下载OST"></p><p>应该是只有终极版玩家才能领取？不过我下面附上了能直接下载的官方链接</p><h1 id="直接下载链接"><a href="#直接下载链接" class="headerlink" title="直接下载链接"></a>直接下载链接</h1><ul><li><a href="https://media.contentapi.ea.com/content/dam/battlefield/battlefield-2042/digital-assets/common/210709-kingston-book-4k-final-english.pdf">直链下载设定集</a></li><li><a href="https://media.contentapi.ea.com/content/dam/battlefield/battlefield-2042/digital-assets/battlefield-2042-exclusive-digital-soundtrack.zip">直链下载OST</a></li></ul><hr><p>希望2042慢慢完善，对得起大家的期待</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT实现使用遗传算法解决旅行商TSP问题</title>
      <link href="/GaforTSP_inQT/"/>
      <url>/GaforTSP_inQT/</url>
      
        <content type="html"><![CDATA[<h1 id="放在前面"><a href="#放在前面" class="headerlink" title="放在前面"></a>放在前面</h1><ul><li>来自广州大学人工智能实验</li><li>仅记录代码实现过程思路,不对涉及知识过多讲解<h1 id="遗传算法解决旅行商问题"><a href="#遗传算法解决旅行商问题" class="headerlink" title="遗传算法解决旅行商问题"></a>遗传算法解决旅行商问题</h1><h2 id="一-对旅行商问题进行编码"><a href="#一-对旅行商问题进行编码" class="headerlink" title="一 对旅行商问题进行编码"></a>一 对旅行商问题进行编码</h2>旅行商问题,目标是求一个走过所有目标地点尽量最短的路径。我们可以将这个路径视为一个数组,数组中的每个元素就是经过的城市的编号,元素的排列顺序就是走过地点的顺序。<br>以遗传算法的视角来看,该数组(路径)中的元素相当于基因,但是这个基因并不重复,因为旅行商问题不会重复走过同一个地点。<br>所以我们可以将每一条路径视为一个数组,数组中的元素就是地点。种群由这些一条条不同的数组(路径)组成。</li></ul><p>在QT中可以用以下这种方式存储路径,元素int类型可以是地点的编号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; path;<span class="comment">//路径</span></span><br></pre></td></tr></table></figure><p>不过我们还是得创建一个location类,将地点信息(名称,坐标等)存储一下,方便后面操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//location.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCATION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCATION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtDebug&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">location</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> X;</span><br><span class="line">    <span class="keyword">int</span> Y;</span><br><span class="line">    <span class="keyword">int</span> code;<span class="comment">//地点代号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    location();</span><br><span class="line">    location(<span class="keyword">int</span> code,<span class="keyword">int</span> X,<span class="keyword">int</span> Y);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qdebugLocation</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCATION_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//location.cpp 部分代码</span></span><br><span class="line">location::location(<span class="keyword">int</span> code,<span class="keyword">int</span> X,<span class="keyword">int</span> Y)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;X=X;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Y=Y;</span><br><span class="line">    <span class="keyword">this</span>-&gt;code=code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">location::getX</span><span class="params">()</span></span></span><br><span class="line">    return this-&gt;X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">location::getY</span><span class="params">()</span></span></span><br><span class="line">    return this-&gt;Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">location::getCode</span><span class="params">()</span></span></span><br><span class="line">    return this-&gt;code;</span><br></pre></td></tr></table></figure><p>然后可以用QVector存储所有地点信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;location&gt; loc;<span class="comment">//地点位置信息</span></span><br></pre></td></tr></table></figure><h2 id="二-遗传算法函数实现"><a href="#二-遗传算法函数实现" class="headerlink" title="二 遗传算法函数实现"></a>二 遗传算法函数实现</h2><p>TSP的遗传算法总体思路:</p><ul><li>a)随机生成N个不同的路径数个体,组成初始种群</li><li>b)使用锦标赛选择策略从种群中选择出新的个体,组成新的交配池</li><li>c)从交配池中随机选择出两个个体,根据交配概率PC交配</li><li>d)如果交配则交配后按照变异概率PM进行变异,不交配直接放入新种群</li><li>e)重复b-d步骤</li></ul><p>我们创建一个GA类来实现TSP的遗传算法,头文件如下<br>后面会仔细讲解每个函数的作用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ga.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;location.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    GA();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init_races</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> num)</span></span>;<span class="comment">//初始化种群</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPathLength</span><span class="params">(QVector&lt;<span class="keyword">int</span>&gt;path, <span class="keyword">int</span> num)</span></span>;<span class="comment">//获取路径总长度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tournament</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> num)</span></span>;<span class="comment">//锦标赛选择,选出交配池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getRandomSwitchPoint</span> <span class="params">(<span class="keyword">int</span> &amp;p1, <span class="keyword">int</span> &amp;p2,<span class="keyword">int</span> size)</span></span>;<span class="comment">//返回p1,p2两个交叉点,保证p2&gt;p1 距离至少为2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crossover</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> num,<span class="keyword">double</span> pc,<span class="keyword">double</span> pm)</span></span>;<span class="comment">//交配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeDuplicates</span><span class="params">(QVector&lt;<span class="keyword">int</span>&gt; &amp;path_1, QVector&lt;<span class="keyword">int</span>&gt; &amp;path_2)</span></span>;<span class="comment">//去除重复</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mutations</span><span class="params">(QVector&lt;<span class="keyword">int</span>&gt;&amp;path,<span class="keyword">int</span> num)</span></span>;<span class="comment">//变异</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMinPathInPool</span><span class="params">(<span class="keyword">int</span> num,QVector&lt;<span class="keyword">int</span>&gt; &amp;minPath)</span></span>;<span class="comment">//取得当前交配池里最短路径长度</span></span><br><span class="line">    <span class="function">QString <span class="title">outputPath</span><span class="params">(QVector&lt;<span class="keyword">int</span>&gt; path)</span></span>;<span class="comment">//打印出路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debugPool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debugPath</span><span class="params">(QVector&lt;<span class="keyword">int</span>&gt; path)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;location&gt; loc;<span class="comment">//地点位置信息</span></span><br><span class="line">    QVector&lt;QVector&lt;<span class="keyword">int</span>&gt;&gt;* pool=<span class="literal">nullptr</span>;<span class="comment">//交配池</span></span><br><span class="line">    QVector&lt;<span class="keyword">int</span>&gt; minPath;<span class="comment">//最小路径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GA_H</span></span></span><br></pre></td></tr></table></figure><h3 id="1-初始化位置信息"><a href="#1-初始化位置信息" class="headerlink" title="1.初始化位置信息"></a>1.初始化位置信息</h3><p>我们在GA的构造函数中编写添加位置信息的代码,这样我们新建GA对象后就已经有位置信息了,在ga.cpp文件中编写代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code in ga.cpp</span></span><br><span class="line">GA::GA()</span><br><span class="line">&#123;<span class="comment">//初始化,添加地点信息</span></span><br><span class="line">    loc.append(location(<span class="number">1</span>,<span class="number">87</span>,<span class="number">7</span>));</span><br><span class="line">    loc.append(location(<span class="number">2</span>,<span class="number">91</span>,<span class="number">38</span>));</span><br><span class="line">    loc.append(location(<span class="number">3</span>,<span class="number">83</span>,<span class="number">46</span>));</span><br><span class="line">    loc.append(location(<span class="number">4</span>,<span class="number">71</span>,<span class="number">44</span>));</span><br><span class="line">    loc.append(location(<span class="number">5</span>,<span class="number">64</span>,<span class="number">60</span>));</span><br><span class="line">    loc.append(location(<span class="number">6</span>,<span class="number">68</span>,<span class="number">58</span>));</span><br><span class="line">    loc.append(location(<span class="number">7</span>,<span class="number">83</span>,<span class="number">69</span>));</span><br><span class="line">    loc.append(location(<span class="number">8</span>,<span class="number">87</span>,<span class="number">76</span>));</span><br><span class="line">    loc.append(location(<span class="number">9</span>,<span class="number">74</span>,<span class="number">78</span>));</span><br><span class="line">    loc.append(location(<span class="number">10</span>,<span class="number">71</span>,<span class="number">71</span>));</span><br><span class="line">    loc.append(location(<span class="number">11</span>,<span class="number">58</span>,<span class="number">62</span>));</span><br><span class="line">    loc.append(location(<span class="number">12</span>,<span class="number">54</span>,<span class="number">62</span>));</span><br><span class="line">    loc.append(location(<span class="number">13</span>,<span class="number">51</span>,<span class="number">67</span>));</span><br><span class="line">    loc.append(location(<span class="number">14</span>,<span class="number">37</span>,<span class="number">84</span>));</span><br><span class="line">    loc.append(location(<span class="number">15</span>,<span class="number">41</span>,<span class="number">94</span>));</span><br><span class="line">    loc.append(location(<span class="number">16</span>,<span class="number">2</span>,<span class="number">99</span>));</span><br><span class="line">    loc.append(location(<span class="number">17</span>,<span class="number">7</span>,<span class="number">64</span>));</span><br><span class="line">    loc.append(location(<span class="number">18</span>,<span class="number">22</span>,<span class="number">60</span>));</span><br><span class="line">    loc.append(location(<span class="number">19</span>,<span class="number">25</span>,<span class="number">62</span>));</span><br><span class="line">    loc.append(location(<span class="number">20</span>,<span class="number">18</span>,<span class="number">54</span>));</span><br><span class="line">    loc.append(location(<span class="number">21</span>,<span class="number">4</span>,<span class="number">50</span>));</span><br><span class="line">    loc.append(location(<span class="number">22</span>,<span class="number">13</span>,<span class="number">40</span>));</span><br><span class="line">    loc.append(location(<span class="number">23</span>,<span class="number">18</span>,<span class="number">40</span>));</span><br><span class="line">    loc.append(location(<span class="number">24</span>,<span class="number">24</span>,<span class="number">42</span>));</span><br><span class="line">    loc.append(location(<span class="number">25</span>,<span class="number">25</span>,<span class="number">38</span>));</span><br><span class="line">    loc.append(location(<span class="number">26</span>,<span class="number">41</span>,<span class="number">26</span>));</span><br><span class="line">    loc.append(location(<span class="number">27</span>,<span class="number">45</span>,<span class="number">35</span>));</span><br><span class="line">    loc.append(location(<span class="number">28</span>,<span class="number">44</span>,<span class="number">35</span>));</span><br><span class="line">    loc.append(location(<span class="number">29</span>,<span class="number">58</span>,<span class="number">35</span>));</span><br><span class="line">    loc.append(location(<span class="number">30</span>,<span class="number">62</span>,<span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把这些信息写入到QVector&lt;int&gt;<br>这个位置信息当然是根据给的题目要求来的,参数分别是 地点编号,X坐标,Y坐标。</p><h3 id="2-生成初始种群"><a href="#2-生成初始种群" class="headerlink" title="2.生成初始种群"></a>2.生成初始种群</h3><blockquote><p>a)随机生成N个不同的路径数个体,组成初始种群</p></blockquote><p>遗传算法第一步就是要生成初始随机种群,思路上面讲了,生成给定种群大小为<strong>NUM</strong>个的随机不同路径,个体用QVector&lt;int&gt;表示,元素int代表地点编号。<br>可以使用启发性的方法生成初始种群，不过我这里就用最简单较差的方法了，直接随机生成。<br>我们可以随机生成<strong>SIZE</strong>个小于SIZE值的int值存储到到这个QVector&lt;int&gt;里(SIZE值就是要走过的地点数,个体的基因数)。<br>举个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; path =&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//path是一个SIZE为5的路径</span></span><br><span class="line"><span class="comment">//其中0,4,...,2代表城市的编号,</span></span><br><span class="line"><span class="comment">//元素顺序代表路径,这里表示路径为0-&gt;4-&gt;1-&gt;3-&gt;2</span></span><br></pre></td></tr></table></figure><p>个体路径的表示方法我们解决了,另外我们还需要还要一个变量<strong>pool</strong>种群来存储全部生成的个体,我们可以写一个QVector&lt;QVector&lt;int&gt;&gt;指针,然后作为GA的私有成员,这样就能方便我们后续迭代,如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in ga.h </span></span><br><span class="line">QVector&lt;QVector&lt;<span class="keyword">int</span>&gt;&gt;* pool=<span class="literal">nullptr</span>;<span class="comment">//交配池,可以用来存储种群</span></span><br></pre></td></tr></table></figure><p>明白之后我们来看如何实现随机初始种群,直接放上代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化随机种群</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GA::init_races</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> num)</span><span class="comment">//size为经过地点数,num是种群大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_ASSERT(<span class="keyword">this</span>-&gt;pool==<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;pool=<span class="keyword">new</span> QVector&lt;QVector&lt;<span class="keyword">int</span>&gt;&gt;;<span class="comment">//实例化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        QVector&lt;<span class="keyword">int</span>&gt; now;<span class="comment">//新建一个个体</span></span><br><span class="line">        <span class="keyword">int</span> tmprand;<span class="comment">//随机数</span></span><br><span class="line">        <span class="function">QVector&lt;<span class="keyword">bool</span>&gt; <span class="title">tmp</span><span class="params">(num,<span class="literal">false</span>)</span></span>;<span class="comment">//用于判断是否重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;num;k++)&#123;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                tmprand=QRandomGenerator::securelySeeded().bounded(num)</span><br><span class="line">                <span class="comment">//生成一个大于等于0小于num的int值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (tmp.at(tmprand)==<span class="literal">true</span>);<span class="comment">//当该值已重复时循环</span></span><br><span class="line">            tmp[tmprand]=<span class="literal">true</span>;<span class="comment">//将该值标记为重复</span></span><br><span class="line">            now.append(tmprand);<span class="comment">//将该值加入到个体</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pool-&gt;append(now);<span class="comment">//将该个体加入到种群pool</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要用到了QRandomGenerator这个类,这个是QT5.10之后加进来的,可以不需要自己另外设种子了(当然你也可以设),官方文档:<a href="https://doc.qt.io/qt-5/qrandomgenerator.html#securelySeeded">QRandomGenerator Class</a></p><p>初始化好的种群在<strong>pool</strong>指针里了</p><h3 id="2-计算适应值-计算路径长度"><a href="#2-计算适应值-计算路径长度" class="headerlink" title="2.计算适应值(计算路径长度)"></a>2.计算适应值(计算路径长度)</h3><p>在开始选择子代之前，我们需要实现一个函数用于计算适应值判断个体对于目标的适应值高低，从而有方向地选择子代个体。<br>在TSP问题中计算适应值就变成了计算路径长度之和了。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GA::getPathLength</span><span class="params">(QVector&lt;<span class="keyword">int</span>&gt;path, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">&quot;getpathlength&quot;</span>;</span><br><span class="line">    Q_ASSERT(num==path.size());</span><br><span class="line">    <span class="keyword">double</span> pathLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;path.size()<span class="number">-1</span>;k++)&#123;</span><br><span class="line">        <span class="comment">//欧氏距离</span></span><br><span class="line">        pathLength+=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(qAbs((<span class="keyword">this</span>-&gt;loc[path[k]].getX())-(<span class="keyword">this</span>-&gt;loc[path[k+<span class="number">1</span>]].getX())),<span class="number">2</span>)+<span class="built_in">pow</span>(qAbs((<span class="keyword">this</span>-&gt;loc[path[k]].getY())-(<span class="keyword">this</span>-&gt;loc[path[k+<span class="number">1</span>]].getY())),<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//曼哈顿距离</span></span><br><span class="line">        <span class="comment">//pathLength+=qAbs((this-&gt;loc[path[k]].getX())-(this-&gt;loc[path[k+1]].getX()))+qAbs((this-&gt;loc[path[k]].getY())-(this-&gt;loc[path[k+1]].getY()));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加上最后一个地点回到开始地点的距离</span></span><br><span class="line">    pathLength+=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(qAbs((<span class="keyword">this</span>-&gt;loc[path.last()].getX())-(<span class="keyword">this</span>-&gt;loc[path.first()].getX())),<span class="number">2</span>)+<span class="built_in">pow</span>(qAbs((<span class="keyword">this</span>-&gt;loc[path.last()].getY())-(<span class="keyword">this</span>-&gt;loc[path.first()].getY())),<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//pathLength+=qAbs((this-&gt;loc[path.last()].getX())-(this-&gt;loc[path.first()].getX()))+qAbs((this-&gt;loc[path.last()].getY())-(this-&gt;loc[path.first()].getY()));</span></span><br><span class="line"></span><br><span class="line">    qDebug()&lt;&lt;<span class="string">&quot;nowpath:&quot;</span>&lt;&lt;pathLength;</span><br><span class="line">    <span class="keyword">return</span> pathLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算距离有两种方式，依据题目要求使用欧氏距离或曼哈顿距离，这里使用的是欧氏距离。另外注意有些题目要求是要从最后一个城市回到最初城市，所以还得加上这个距离。</p><h3 id="3-筛选出交配池"><a href="#3-筛选出交配池" class="headerlink" title="3.筛选出交配池"></a>3.筛选出交配池</h3><blockquote><p>b)使用锦标赛选择策略从种群中选择出新的个体,组成新的交配池<br>其实筛选个体的方法除了锦标赛算法还有一个轮盘赌算法选择的方法，不过这里用的是锦标赛算法，轮盘赌算法就不介绍了，有兴趣可以自行了解。</p></blockquote><blockquote><p>遗传算法中的锦标赛选择策略每次从种群中取出一定数量个体（放回抽样），然后选择其中最好的一个进入子代种群。重复该操作，直到新的种群规模达到原来的种群规模。几元锦标赛就是一次性在总体中取出几个个体，然后在这些个体中取出最优的个体放入保留到下一代种群的集合中。</p></blockquote><p>这里我们采用二元锦标赛，每次选出两个（放回）进行比较路径长度大小,将较小的的路径加入到新交配池子<br>直接看代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GA::tournament</span><span class="params">( <span class="keyword">int</span> size,<span class="keyword">int</span> num)</span><span class="comment">//锦标赛选择新交配池</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">&quot;tournament&quot;</span>;</span><br><span class="line">    Q_ASSERT(size&gt;<span class="number">0</span>);</span><br><span class="line">    QVector&lt;QVector&lt;<span class="keyword">int</span>&gt;&gt; *newpool=<span class="keyword">new</span> QVector&lt;QVector&lt;<span class="keyword">int</span>&gt;&gt;;<span class="comment">//新池子</span></span><br><span class="line">    <span class="keyword">int</span> time=size;</span><br><span class="line">    <span class="keyword">while</span>(time--)&#123;</span><br><span class="line">        <span class="keyword">int</span> index_1=QRandomGenerator::system()-&gt;bounded(size);<span class="comment">//随机数作为下标</span></span><br><span class="line">        <span class="keyword">int</span> index_2=QRandomGenerator::system()-&gt;bounded(size);</span><br><span class="line">        <span class="comment">//比较路径长度</span></span><br><span class="line">        <span class="keyword">if</span>(getPathLength(<span class="keyword">this</span>-&gt;pool-&gt;at(index_1),num)&lt;getPathLength(<span class="keyword">this</span>-&gt;pool-&gt;at(index_2),num))&#123;</span><br><span class="line">            newpool-&gt;append(<span class="keyword">this</span>-&gt;pool-&gt;at(index_1));<span class="comment">//将该路径加入到新池子</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newpool-&gt;append(<span class="keyword">this</span>-&gt;pool-&gt;at(index_2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;pool;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pool=newpool;</span><br><span class="line">    debugPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-进行交配和变异"><a href="#4-进行交配和变异" class="headerlink" title="4.进行交配和变异"></a>4.进行交配和变异</h3><blockquote><p>c)从交配池中随机选择出两个个体,根据交配概率PC交配<br>d)如果交配则交配后按照变异概率PM进行变异,不交配直接放入新种群</p></blockquote><p>这一步我们需要随机选出两个个体,根据交配概率PC判断是否进行交配,如果不交配,那我们直接将这两个个体放入新种群(交配池)即可;如果交配,则要进行交配策略，进行交配策略之后还要根据变异概率PM是否进行变异</p><p>遗传算法中如何进行交配呢? 常用的策略方法有一点交叉和两点交叉</p><blockquote><p>交叉的步骤如下：<br>1.从交配池中随机选出两个个体作为需要交叉的个体<br>2.根据个体基因长度SIZE，随机生成一个或多个范围在[0,size-1]的整数下标点作为交叉点<br>3.交换两个个体由交叉点指定的基因范围部分‘</p></blockquote><p>一点交叉：<br>就是只选择一个交叉点进行交换<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211128193901.png"><br>两点交叉：<br>两个交叉点，将两个交叉点之间的基因部分交换<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211128194004.png"><br>要注意的是，交换后会出现部分基因重复，也就是地点重复，这是不允许的，所以我们要去掉重复地点<br>方法很简单，分别找到两个个体中重复的部分，然后互相交换即可。</p><p>然后再说说变异，变异在tsp问题中我们用一种简单的方法进行处理：随机交换一个个体中两个基因的位置。<br>也就是随机选取两个地点交换在路径中的位置<br>例如：1-&gt;2-&gt;3-&gt;4<br>可以变异为 1-&gt;4-&gt;3-&gt;2(交换了2和4的位置)</p><p>理解后我们就可以写代码了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得两个符合规则的交叉点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GA::getRandomSwitchPoint</span><span class="params">(<span class="keyword">int</span> &amp;p1,<span class="keyword">int</span> &amp;p2,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Q_ASSERT(p1&gt;=0&amp;&amp;p2&gt;=0);</span></span><br><span class="line">    <span class="keyword">int</span> tmp1,tmp2;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        tmp1=QRandomGenerator::system()-&gt;bounded(num);</span><br><span class="line">        tmp2=QRandomGenerator::system()-&gt;bounded(num);</span><br><span class="line">    &#125;<span class="keyword">while</span>(tmp1&gt;=tmp2&amp;&amp;!((tmp2-tmp1)&gt;=<span class="number">2</span>));</span><br><span class="line">    p1=tmp1;</span><br><span class="line">    p2=tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去除重复</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GA::removeDuplicates</span><span class="params">(QVector&lt;<span class="keyword">int</span>&gt; &amp;path_1, QVector&lt;<span class="keyword">int</span>&gt; &amp;path_2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">&quot;removeDuplicates&quot;</span>;</span><br><span class="line">    <span class="comment">//找出第一个个体的重复基因</span></span><br><span class="line">    QVector&lt;<span class="keyword">int</span>&gt; duplicates_1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=path_1.begin();i!=path_1.end();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(path_1.count(*i)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(duplicates_1.contains(*i)==<span class="literal">false</span>)</span><br><span class="line">                duplicates_1.append(*i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出第二个个体的重复基因</span></span><br><span class="line">    QVector&lt;<span class="keyword">int</span>&gt; duplicates_2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=path_2.begin();i!=path_2.end();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(path_2.count(*i)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(duplicates_2.contains(*i)==<span class="literal">false</span>)</span><br><span class="line">                duplicates_2.append(*i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换重复的基因</span></span><br><span class="line">    <span class="keyword">if</span>(duplicates_1.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        debugPath(duplicates_1);</span><br><span class="line">        debugPath(duplicates_2);</span><br><span class="line">        Q_ASSERT(duplicates_1.size()==duplicates_2.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;duplicates_1.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp= path_1[path_1.indexOf(duplicates_1[i])];</span><br><span class="line">            path_1[path_1.indexOf(duplicates_1[i])]=duplicates_2[i];</span><br><span class="line">            path_2[path_2.indexOf(duplicates_2[i])]=tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        debugPath(path_1);</span><br><span class="line">        debugPath(path_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二点交叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GA::crossover</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> num,<span class="keyword">double</span> pc,<span class="keyword">double</span> pm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_ASSERT(<span class="keyword">this</span>-&gt;pool-&gt;size()&gt;<span class="number">0</span>);</span><br><span class="line">    Q_ASSERT(size&gt;<span class="number">0</span>&amp;&amp;num&gt;<span class="number">0</span>);</span><br><span class="line">    Q_ASSERT(pc&gt;=<span class="number">0</span>&amp;&amp;pc&lt;=<span class="number">1</span>);</span><br><span class="line">    QVector&lt;QVector&lt;<span class="keyword">int</span>&gt;&gt;* newPool=<span class="keyword">new</span>  QVector&lt;QVector&lt;<span class="keyword">int</span>&gt;&gt;;<span class="comment">//新池子</span></span><br><span class="line">    <span class="keyword">int</span> time=size;</span><br><span class="line">    <span class="keyword">while</span> (time--) &#123;</span><br><span class="line">        <span class="comment">//随机取出两个路径个体</span></span><br><span class="line">        <span class="keyword">int</span> rand_1=QRandomGenerator::system()-&gt;bounded(size);</span><br><span class="line">        <span class="keyword">int</span> rand_2=QRandomGenerator::system()-&gt;bounded(size);</span><br><span class="line">        QVector&lt;<span class="keyword">int</span>&gt; tmpPath_1=<span class="keyword">this</span>-&gt;pool-&gt;at(rand_1);</span><br><span class="line">        QVector&lt;<span class="keyword">int</span>&gt; tmpPath_2=<span class="keyword">this</span>-&gt;pool-&gt;at(rand_2);</span><br><span class="line">        debugPath(tmpPath_1);</span><br><span class="line">        debugPath(tmpPath_2);</span><br><span class="line">        <span class="comment">//生成一个0~1.0的随机数,如果大于给定的PC值则不交配,否则交配</span></span><br><span class="line">        <span class="keyword">double</span> randPC=<span class="keyword">double</span>(QRandomGenerator::system()-&gt;bounded(<span class="number">1.0</span>));</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">&quot;randpc:&quot;</span>&lt;&lt;randPC;</span><br><span class="line">        Q_ASSERT(randPC&lt;<span class="number">1</span>&amp;&amp;rand()&gt;=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(randPC&gt;pc)&#123;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">&quot;不交配&quot;</span>;</span><br><span class="line">            newPool-&gt;append(tmpPath_1);</span><br><span class="line">            newPool-&gt;append(tmpPath_2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">&quot;交配&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> crossPos_1,crossPos_2;</span><br><span class="line">            <span class="comment">//获得交叉点</span></span><br><span class="line">            getRandomSwitchPoint(crossPos_1,crossPos_2,num);</span><br><span class="line">            Q_ASSERT(crossPos_2&gt;crossPos_1);</span><br><span class="line">           <span class="comment">// QVector&lt;int&gt; tmpp;</span></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=crossPos_1;i&lt;crossPos_2;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmppp=tmpPath_1[i];</span><br><span class="line">                tmpPath_1[i]=tmpPath_2[i];</span><br><span class="line">                tmpPath_2[i]=tmppp;</span><br><span class="line">            &#125;</span><br><span class="line">            debugPath(tmpPath_1);</span><br><span class="line">            debugPath(tmpPath_2);</span><br><span class="line">            <span class="comment">//去除重复</span></span><br><span class="line">            removeDuplicates(tmpPath_1,tmpPath_2);</span><br><span class="line">            <span class="keyword">double</span> randPM=<span class="keyword">double</span>(QRandomGenerator::system()-&gt;bounded(<span class="number">1.0</span>));</span><br><span class="line">            <span class="keyword">if</span>(randPM&lt;pm)&#123;</span><br><span class="line">                qDebug()&lt;&lt;<span class="string">&quot;mutations&quot;</span>;</span><br><span class="line">                mutations(tmpPath_1,num);</span><br><span class="line">                mutations(tmpPath_2,num);</span><br><span class="line">                debugPath(tmpPath_1);</span><br><span class="line">                debugPath(tmpPath_2);</span><br><span class="line">            &#125;</span><br><span class="line">            newPool-&gt;append(tmpPath_1);</span><br><span class="line">            newPool-&gt;append(tmpPath_2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">    pool=newPool;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变异</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GA::mutations</span><span class="params">(QVector&lt;<span class="keyword">int</span>&gt; &amp;path,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> randIndex_1=QRandomGenerator::system()-&gt;bounded(num);</span><br><span class="line">    <span class="keyword">int</span> randIndex_2=QRandomGenerator::system()-&gt;bounded(num);</span><br><span class="line">    <span class="keyword">if</span>(randIndex_1!=randIndex_2)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=path[randIndex_1];</span><br><span class="line">        path[randIndex_1]=path[randIndex_2];</span><br><span class="line">        path[randIndex_2]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样遗传算法对于TSP问的的实现就基本写好了<br>接下来我们设计个可视化界面，方便我们查看遗传算法不同参数对于结果的影响</p><h2 id="三-设计可视化界面"><a href="#三-设计可视化界面" class="headerlink" title="三 设计可视化界面"></a>三 设计可视化界面</h2><p>目标：<br>1.可以设定PM概率，PC概率，种群大小和迭代次数<br>2.结果用折线图显示，方便查看</p><h3 id="1-设计-ui文件"><a href="#1-设计-ui文件" class="headerlink" title="1.设计.ui文件"></a>1.设计.ui文件</h3><p>简单设计一下即可，留出给设置变量的lineEdit组件，下面是我设计的界面<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211128205510.png" alt="主界面"></p><p>在文本框输入参数值，点击执行结果按钮计算结果，能够将结果中的最短路径长度和路径显示出来，也能显示耗时</p><h3 id="2-实现显示折线图"><a href="#2-实现显示折线图" class="headerlink" title="2.实现显示折线图"></a>2.实现显示折线图</h3><p>QT中有提供实现相关视图的类，要实现折线图需要用到下面几个头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineSeries&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QValueAxis&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QChartView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QChart&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这里不对使用的类做过多介绍，可以自行查看QT官方文档，大概用法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">QLineSeries *series = <span class="keyword">new</span> QLineSeries()<span class="comment">//QLineSeries类能在图表中中显示数据</span></span><br><span class="line">series-&gt;append(X,Y);<span class="comment">//将坐标为（X，Y）的点添加到QLineSeries中</span></span><br><span class="line">QChart *chart = <span class="keyword">new</span> QChart();<span class="comment">//QChart 类管理图数据、图例和轴的图形表示</span></span><br><span class="line">chart-&gt;legend()-&gt;hide();<span class="comment">//隐藏图例</span></span><br><span class="line">chart-&gt;createDefaultAxes();<span class="comment">//设置默认轴</span></span><br><span class="line">chart-&gt;setTitle(<span class="string">&quot;XXX&quot;</span>);<span class="comment">//设置标题</span></span><br><span class="line">QValueAxis *aX=<span class="keyword">new</span> QValueAxis;<span class="comment">//实例化两个轴对象，分别作为X轴Y轴</span></span><br><span class="line">QValueAxis *aY=<span class="keyword">new</span> QValueAxis;</span><br><span class="line">aX-&gt;setTitleText(<span class="string">&quot;次数&quot;</span>);<span class="comment">//设置轴标题</span></span><br><span class="line">aX-&gt;setLabelFormat(<span class="string">&quot;%d&quot;</span>);<span class="comment">//设置轴标签格式</span></span><br><span class="line">aX-&gt;setTitleVisible(<span class="literal">true</span>);<span class="comment">//设置显示轴  </span></span><br><span class="line">aY-&gt;setTitleVisible(<span class="literal">true</span>);</span><br><span class="line">aY-&gt;setLabelFormat(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">aY-&gt;setTitleText(<span class="string">&quot;路径长度&quot;</span>);</span><br><span class="line">chart-&gt;addAxis(aX,Qt::AlignBottom);<span class="comment">//给chart加上轴</span></span><br><span class="line">chart-&gt;addAxis(aY,Qt::AlignLeft);</span><br><span class="line">chart-&gt;addSeries(series);<span class="comment">//给chart加上数据</span></span><br><span class="line">series-&gt;attachAxis(aX);<span class="comment">//给数据也加上轴（需要先addSeries</span></span><br><span class="line">series-&gt;attachAxis(aY);</span><br><span class="line">QChartView *chartView = <span class="keyword">new</span> QChartView(chart);<span class="comment">//QChartView是用于显示QChart的布局</span></span><br><span class="line">chartView-&gt;setRenderHint(QPainter::Antialiasing);<span class="comment">//抗锯齿</span></span><br><span class="line">QMainWindow *chartV=<span class="keyword">new</span> QMainWindow;<span class="comment">//实例个QMainWindo对象来显示chartView</span></span><br><span class="line">chartV-&gt;setCentralWidget(chartView);</span><br><span class="line">chartV-&gt;resize(<span class="number">800</span>, <span class="number">500</span>);<span class="comment">//设置窗口大小</span></span><br><span class="line">chartV-&gt;show();<span class="comment">//显示</span></span><br></pre></td></tr></table></figure><h3 id="3-按钮槽函数编写"><a href="#3-按钮槽函数编写" class="headerlink" title="3.按钮槽函数编写"></a>3.按钮槽函数编写</h3><p>这部分应该不用多说了，给“执行按钮”写一个信号为点击的槽函数，然后执行遗传算法，不用多说直接上代码吧，这里也直接把上一步折线图的实现写进来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line">QT_CHARTS_USE_NAMESPACE<span class="comment">//注意要加上这个</span></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">    , ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//给lineedit填上默认值</span></span><br><span class="line">    ui-&gt;cycleEdit-&gt;setText(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    ui-&gt;pcEdit-&gt;setText(<span class="string">&quot;0.5&quot;</span>);</span><br><span class="line">    ui-&gt;pmEdit-&gt;setText(<span class="string">&quot;0.3&quot;</span>);</span><br><span class="line">    ui-&gt;sizeEdit-&gt;setText(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_resultBtn_clicked</span><span class="params">()</span><span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取变量信息</span></span><br><span class="line">        <span class="keyword">int</span> size=ui-&gt;sizeEdit-&gt;text().toInt();</span><br><span class="line">        <span class="keyword">double</span> pc=ui-&gt;pcEdit-&gt;text().toDouble();</span><br><span class="line">        <span class="keyword">double</span> pm=ui-&gt;pmEdit-&gt;text().toDouble();</span><br><span class="line">        <span class="keyword">int</span> cycletime=ui-&gt;cycleEdit-&gt;text().toInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(size&lt;=<span class="number">0</span>||pc&lt;=<span class="number">0</span>||pm&lt;=<span class="number">0</span>||cycletime&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">&quot;out&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> QString(<span class="string">&quot;输入值非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GA tsp;</span><br><span class="line">        <span class="keyword">int</span> path;</span><br><span class="line"></span><br><span class="line">        tsp.init_races(size,<span class="number">30</span>);<span class="comment">//生成随机初始种群</span></span><br><span class="line"></span><br><span class="line">        QLineSeries *series = <span class="keyword">new</span> QLineSeries();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minPathGlobalValue=INT32_MAX;</span><br><span class="line">        QVector&lt;<span class="keyword">int</span>&gt; minPathGlobal;<span class="comment">//用于存储最小路径</span></span><br><span class="line">        QTime cTime;<span class="comment">//用于计时</span></span><br><span class="line">        cTime.start();</span><br><span class="line">        <span class="keyword">int</span> time=cycletime;</span><br><span class="line">        <span class="keyword">while</span>(time--)&#123;</span><br><span class="line">            tsp.tournament(size,<span class="number">30</span>);<span class="comment">//选择个体（锦标赛选择）</span></span><br><span class="line">            tsp.crossover(size,<span class="number">30</span>,pc,pm);<span class="comment">//交配</span></span><br><span class="line">            QVector&lt;<span class="keyword">int</span>&gt; minPath;</span><br><span class="line">            path=tsp.getMinPathInPool(<span class="number">30</span>,minPath);<span class="comment">//取得当前路径</span></span><br><span class="line">            series-&gt;append(cycletime - time,path);<span class="comment">//给折线图添加点</span></span><br><span class="line">            <span class="keyword">if</span>(path&lt;minPathGlobalValue)&#123;<span class="comment">//存储最小路径</span></span><br><span class="line">                minPathGlobalValue=path;</span><br><span class="line">                minPathGlobal=minPath;</span><br><span class="line">            &#125;</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">&quot;PATH:&quot;</span>&lt;&lt;path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> runtime=cTime.elapsed();<span class="comment">//结束计时</span></span><br><span class="line">        <span class="comment">//打印显示</span></span><br><span class="line">        ui-&gt;runtime-&gt;setText(QString(<span class="string">&quot;花费时间:%1ms&quot;</span>).arg(runtime));</span><br><span class="line">        ui-&gt;pathValue-&gt;setText(QString::number(minPathGlobalValue));</span><br><span class="line">        ui-&gt;path-&gt;setText(tsp.outputPath(minPathGlobal));</span><br><span class="line">        <span class="comment">//绘制折线图</span></span><br><span class="line">        QChart *chart = <span class="keyword">new</span> QChart();</span><br><span class="line">        chart-&gt;legend()-&gt;hide();</span><br><span class="line">        chart-&gt;createDefaultAxes();</span><br><span class="line">        chart-&gt;setTitle(QString(<span class="string">&quot;遗传算法解决旅行商问题 PC:%1 PM:%2 种群规模:%3&quot;</span>).arg(pc).arg(pm).arg(size));</span><br><span class="line">        QValueAxis *aX=<span class="keyword">new</span> QValueAxis;</span><br><span class="line">        QValueAxis *aY=<span class="keyword">new</span> QValueAxis;</span><br><span class="line">        aX-&gt;setTitleText(<span class="string">&quot;次数&quot;</span>);</span><br><span class="line">        aX-&gt;setLabelFormat(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">        aX-&gt;setTitleVisible(<span class="literal">true</span>);</span><br><span class="line">        aY-&gt;setTitleVisible(<span class="literal">true</span>);</span><br><span class="line">        aY-&gt;setLabelFormat(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">        aY-&gt;setTitleText(<span class="string">&quot;路径长度&quot;</span>);</span><br><span class="line">        chart-&gt;addAxis(aX,Qt::AlignBottom);</span><br><span class="line">        chart-&gt;addAxis(aY,Qt::AlignLeft);</span><br><span class="line">        chart-&gt;addSeries(series);</span><br><span class="line">        series-&gt;attachAxis(aX);<span class="comment">//需要先addSeries</span></span><br><span class="line">        series-&gt;attachAxis(aY);</span><br><span class="line">        QChartView *chartView = <span class="keyword">new</span> QChartView(chart);</span><br><span class="line">        chartView-&gt;setRenderHint(QPainter::Antialiasing);</span><br><span class="line">        QMainWindow *chartV=<span class="keyword">new</span> QMainWindow;</span><br><span class="line">        chartV-&gt;setCentralWidget(chartView);</span><br><span class="line">        chartV-&gt;resize(<span class="number">800</span>, <span class="number">500</span>);</span><br><span class="line">        chartV-&gt;show();</span><br><span class="line"></span><br><span class="line">    &#125;  <span class="keyword">catch</span> (QString warningInfo) &#123;</span><br><span class="line">        QMessageBox::warning(<span class="keyword">this</span>,<span class="string">&quot;警告&quot;</span>,warningInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了：使用QT实现遗传算法处理旅行商问题<br>程序完整源码我会放在文章后面</p><h2 id="四-运行结果"><a href="#四-运行结果" class="headerlink" title="四 运行结果"></a>四 运行结果</h2><p>主界面<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129193740.png"><br>点击”执行结果”执行遗传算法</p><p>视给定的参数不同，耗时也不同<br>计算完会弹出一个窗口<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129193908.png"><br>然后主界面也会更新<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129194006.png"></p><p>我所设定的地点信息的最短路径其实是按城市编号从小到大的顺序为最短。最短路径为415左右，可以看到这遗传算法执行出来的结果还是差距蛮大的，接下来我们换几个参数看看。</p><ul><li>PC= 0.7 PM=0.1 size=20<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129194302.png"><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129194238.png"></li><li>PC= 0.7 PM=0.1 size=20 time=200<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129194447.png"><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129194505.png"></li><li>PC= 0.8 PM=0.2 size=20 time=1000<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129194630.png"><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211129194643.png"></li></ul><p>不同参数对计算结果影响也不同，参数的选择也是遗传算法比较关键的地方。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>作为学校人工智能的实验之一，遗传算法解决TSP问题让我又学到了不少算法相关的东西，还新接触了QT的图表类，收获颇多。也让我对TSP问题又多了一丝兴趣，而遗传算法本身也十分有趣，运用基因遗传仿生学来作为算法也是令人惊讶赞叹不已。</p><p>Reference：</p><ul><li><a href="https://www.xerrors.fun/Genetic-algorithm-tsp/#%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5">遗传算法 - TSP旅行商问题求解</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95">遗传算法 - 维基百科</a></li></ul><p>项目源码：<a href="https://github.com/HK560/GAforTSP">Github</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> QT项目 </category>
          
          <category> 专业学习实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决vscode终端执行hexo命令提示无法加载文件因为在此系统上禁止运行脚本</title>
      <link href="/FixedvscodeterminalScriptForbiddenToRun/"/>
      <url>/FixedvscodeterminalScriptForbiddenToRun/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天在用vscode的终端创建hexo文章时候,执行hexo new 时候得到如下错误提示<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211126093838.png"></p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>原因已经告诉我们了,因为当前系统上的powershell策略不允许我们执行脚本</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>使用管理员身份打开powershell<br>输入命令 get-ExecutionPolicy</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\WINDOWS\system32&gt; <span class="built_in">get-ExecutionPolicy</span></span><br><span class="line">Restricted</span><br></pre></td></tr></table></figure><p>返回结果为Restricted 微软doc说明如下:</p><blockquote><p>Restricted<br>The default execution policy for Windows client computers.<br>Permits individual commands, but does not allow scripts.<br>Prevents running of all script files, including formatting and configuration files (.ps1xml), module script files (.psm1), and PowerShell profiles (.ps1).</p></blockquote><p>简单来说运行执行单独的命令,不允许执行脚本,阻止运行所有脚本文件,包括格式和配置文件(.ps1xml),模块脚本文件(.psm1)和powershell配置文件(.ps1)。</p><p>我们使用Set-ExecutionPolicy  RemoteSigned 修改策略</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\WINDOWS\system32&gt; <span class="built_in">Set-ExecutionPolicy</span>  RemoteSigned</span><br><span class="line"></span><br><span class="line">执行策略更改</span><br><span class="line">执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险,如 https:/go.microsoft.com/fwlink/?LinkID=<span class="number">135170</span></span><br><span class="line">中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?</span><br><span class="line">[<span class="type">Y</span>] 是(Y)  [<span class="type">A</span>] 全是(A)  [<span class="type">N</span>] 否(N)  [<span class="type">L</span>] 全否(L)  [<span class="type">S</span>] 暂停(S)  [?] 帮助 (默认值为“N”): Y</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:\WINDOWS\system32&gt; <span class="built_in">get-ExecutionPolicy</span></span><br><span class="line">RemoteSigned</span><br></pre></td></tr></table></figure><p>这样就可以运行脚本了。回到vscode执行hexo new命令<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211126095750.png"><br>发现已经可以正常执行了,问题解决!</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>关于 RemoteSigned 说明:</p><blockquote><p>RemoteSigned<br>The default execution policy for Windows server computers.<br>Scripts can run.<br>Requires a digital signature from a trusted publisher on scripts and configuration files that are downloaded from the internet which includes email and instant messaging programs.<br>Doesn’t require digital signatures on scripts that are written on the local computer and not downloaded from the internet.<br>Runs scripts that are downloaded from the internet and not signed, if the scripts are unblocked, such as by using the Unblock-File cmdlet.<br>Risks running unsigned scripts from sources other than the internet and signed scripts that could be malicious.</p></blockquote><p>可以运行脚本,条件:<br>1.该脚本是在从互联网上下载的脚本和配置文件拥有可信发布者的数字签名,文件包括email和instant messaging programs.<br>2.本地的脚本则不需要数字签名也能运行<br>3.网上下载的没有签名的unblocked的脚本可以运行</p><p>谨防从Internet以外的来源运行未签名的脚本和可能是恶意的签名脚本。</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/?view=powershell-7.2">microsoft.powershell.security</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实验朴素贝叶斯逻辑回归处理adult数据集(附代码)</title>
      <link href="/MachineLearningExperimentNaiveBayesianLogisticRegressionProcessingadultDataset/"/>
      <url>/MachineLearningExperimentNaiveBayesianLogisticRegressionProcessingadultDataset/</url>
      
        <content type="html"><![CDATA[<h1 id="放在最前面"><a href="#放在最前面" class="headerlink" title="放在最前面"></a>放在最前面</h1><ul><li>题目来自广州大学机器学习实验</li><li>本文以解决数据集处理问题为最高目标，不会对涉及到的知识过多介绍，会写出问题解决思路方式<h1 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h1><blockquote><p>基于Adult数据集，完成关于收入是否大于50K的逻辑回归分类、朴素贝叶斯模型训练、测试与评估。</p></blockquote></li><li>1 准备数据集并认识数据<br>  下载Adult数据集<br>  <a href="http://archive.ics.uci.edu/ml/datasets/Adult">http://archive.ics.uci.edu/ml/datasets/Adult</a><br>  了解数据集各个维度特征及预测值的含义</li><li>2 探索数据并预处理数据<br>  观察数据集各个维度特征及预测值的数值类型与分布<br>  预处理各维度特征</li><li>3 训练模型<br>  编程实现训练数据集上逻辑回归模型的梯度下降参数求解、朴素贝叶斯参数统计</li><li>4 测试和评估模型<br>   在测试数据集上计算所训练模型的准确率、AUC等指标</li></ul><h1 id="实验内容及步骤"><a href="#实验内容及步骤" class="headerlink" title="实验内容及步骤"></a>实验内容及步骤</h1><h2 id="数据集下载处理"><a href="#数据集下载处理" class="headerlink" title="数据集下载处理"></a>数据集下载处理</h2><pre><code>http://archive.ics.uci.edu/ml/datasets/Adult</code></pre><p>下载后用excel打开文件，发现没有index没有列名，只好手动处理添加一下，处理好的文件我会放在源码文件夹里。<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20211126101609.png"></p><p>使用pandas读取文件,简单处理一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数据,预处理</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;adult.csv&#x27;</span>) </span><br><span class="line"><span class="comment">#去掉含有nan的行</span></span><br><span class="line">df=df.dropna(axis=<span class="number">0</span>,how=<span class="string">&#x27;any&#x27;</span>)</span><br></pre></td></tr></table></figure><p>观察数据发现,有些地方有缺省值,用”?”表示,我们需要去掉这些含有问号的行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#预处理，去掉缺省属性的行</span></span><br><span class="line">df=df[~df[<span class="string">&#x27;workclass&#x27;</span>].isin([<span class="string">&quot;?&quot;</span>])]</span><br><span class="line">df=df[~df[<span class="string">&#x27;native-country&#x27;</span>].isin([<span class="string">&quot;?&quot;</span>])]</span><br><span class="line">df=df[~df[<span class="string">&#x27;occupation&#x27;</span>].isin([<span class="string">&quot;?&quot;</span>])]</span><br></pre></td></tr></table></figure><p>因为是要分类收入大于50K和小于等于50K的,我们直接处理一下,将大于50k的设为1,小于等于50k的设为0,放在新的一个列,列名target</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将结果转为二分类值为0 1方便后续处理。重命名为target列</span></span><br><span class="line">df.loc[df[<span class="string">&#x27;income&#x27;</span>] == <span class="string">&quot;&gt;50K&quot;</span>,<span class="string">&quot;target&quot;</span>] = <span class="number">1</span></span><br><span class="line">df.loc[df[<span class="string">&#x27;income&#x27;</span>] != <span class="string">&quot;&gt;50K&quot;</span>,<span class="string">&quot;target&quot;</span>] = <span class="number">0</span></span><br><span class="line">df.drop([<span class="string">&#x27;income&#x27;</span>], axis=<span class="number">1</span> ,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="1-逻辑回归分类"><a href="#1-逻辑回归分类" class="headerlink" title="1.逻辑回归分类"></a>1.逻辑回归分类</h3><p>继续往下面看前建议先执行了解一下逻辑回归是什么东西,这里不再细说展开,直接写代码</p><p>预处理完之后,与朴素贝叶斯不同<br>我们还需要将离散型特征和连续性特征筛选出来,进行处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选出离散型特征</span></span><br><span class="line">cat_columns = [<span class="string">&#x27;workclass&#x27;</span>, <span class="string">&#x27;education&#x27;</span>, <span class="string">&#x27;marital-status&#x27;</span>, <span class="string">&#x27;occupation&#x27;</span>, <span class="string">&#x27;relationship&#x27;</span>, <span class="string">&#x27;race&#x27;</span>, </span><br><span class="line">               <span class="string">&#x27;gender&#x27;</span>,<span class="string">&#x27;native-country&#x27;</span>]</span><br><span class="line"><span class="comment">#连续性特征</span></span><br><span class="line">num_columns = [<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;fnlwgt&#x27;</span>,<span class="string">&#x27;educational-num&#x27;</span>,<span class="string">&#x27;capital-gain&#x27;</span>, <span class="string">&#x27;capital-loss&#x27;</span>, <span class="string">&#x27;hours-per-week&#x27;</span>]</span><br><span class="line"><span class="comment">#目标特征</span></span><br><span class="line">target_column = <span class="string">&quot;target&quot;</span></span><br><span class="line"><span class="comment">#对离散型特征独热编码</span></span><br><span class="line">encoded_df = pd.get_dummies(df,columns=cat_columns)</span><br><span class="line"></span><br><span class="line"><span class="comment">#特征值</span></span><br><span class="line">df_x = encoded_df.drop(columns=<span class="string">&quot;target&quot;</span>)</span><br><span class="line"><span class="comment">#目标值</span></span><br><span class="line">df_y = encoded_df[<span class="string">&quot;target&quot;</span>].values</span><br></pre></td></tr></table></figure><p>然后把连续型特征的值归一化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将连续型特征值归一化</span></span><br><span class="line">num_mean = df_x[num_columns].mean()</span><br><span class="line">num_std = df_x[num_columns].std()</span><br><span class="line">num_normol = (df_x[num_columns] - num_mean)/num_std</span><br><span class="line">df_x.drop(columns=num_columns,inplace=<span class="literal">True</span>)</span><br><span class="line">df_x = pd.concat([df_x,num_normol],axis=<span class="number">1</span>).values   </span><br></pre></td></tr></table></figure><p>然后就可以划分训练集和测试集了,使用sklearn的库划分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#划分训练集测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedShuffleSplit</span><br><span class="line">sss = StratifiedShuffleSplit(n_splits=<span class="number">2</span>,train_size=<span class="number">0.7</span>)</span><br><span class="line"><span class="keyword">for</span> train_index,test_index <span class="keyword">in</span> sss.split(df_x,df_y):</span><br><span class="line">    trainx,testx = df_x[train_index],df_x[test_index]</span><br><span class="line">    trainy,testy = df_y[train_index],df_y[test_index]</span><br></pre></td></tr></table></figure><p>接下来我们就要着手实现逻辑回归了,不了解逻辑回归的强烈建议先执行学习一下</p><p>实现sigmoid函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">x</span>):</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br></pre></td></tr></table></figure><p>梯度下降法的逻辑回归实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">X=trainx</span><br><span class="line">Y=np.reshape(trainy, (-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">X_test=testx</span><br><span class="line">Y_test=np.reshape(testy, (-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># print(X.shape)</span></span><br><span class="line"><span class="comment"># print (Y.shape)</span></span><br><span class="line"></span><br><span class="line">theta=np.zeros(shape=[<span class="number">1</span>,X.shape[<span class="number">1</span>]])</span><br><span class="line">b=<span class="number">0</span></span><br><span class="line"><span class="comment">#设置学习速率</span></span><br><span class="line">alpha= <span class="number">0.001</span></span><br><span class="line"><span class="comment">#学习次数</span></span><br><span class="line">learning_count =<span class="number">1000</span></span><br><span class="line">theta = np.zeros(shape=[<span class="number">1</span>, X.shape[<span class="number">1</span>]])</span><br><span class="line">theta = theta.T</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(learning_count):</span><br><span class="line">    pre = np.dot(X, theta)</span><br><span class="line">    w = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-pre))  </span><br><span class="line">    h = np.dot(X.T, (Y - w))  </span><br><span class="line">    h = h / <span class="built_in">len</span>(h)</span><br><span class="line">    lost = -(np.dot(Y.T, np.log(w)) + np.dot((<span class="number">1</span> - Y).T, np.log(<span class="number">1</span> - w))) / <span class="built_in">len</span>(Y)</span><br><span class="line">    theta = theta + alpha * h</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">10000</span>==<span class="number">0</span>:</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;梯度下降中...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y_pre= np.dot(X_test,theta)+b</span><br><span class="line">y_preSigmd=sigmoid(y_pre)</span><br></pre></td></tr></table></figure><p>这样求出的预测值并不能直接和测试值比较,我们以0.5划分是0是1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_preSigmd= np.where(y_preSigmd&gt;<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>好这样y_preSigmod里就是我们根据测试集预测出来的值</p><p>计算一下准确率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">print(<span class="string">&quot;准确率：&quot;</span>,accuracy_score(y_preSigmd, Y_test))</span><br></pre></td></tr></table></figure><p>AUC值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line">auc_score = roc_auc_score(Y_test,y_preSigmd)</span><br><span class="line">print(<span class="string">&quot;AUC值:&quot;</span>,auc_score)</span><br></pre></td></tr></table></figure><h3 id="2-朴树贝叶斯分类"><a href="#2-朴树贝叶斯分类" class="headerlink" title="2.朴树贝叶斯分类"></a>2.朴树贝叶斯分类</h3><p>预处理完之后,与逻辑回归不同,我们需要着重处理连续型特征,将其划分为几个区间特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将连续型特征划分区间</span></span><br><span class="line">df[<span class="string">&#x27;age&#x27;</span>]=pd.cut(df[<span class="string">&#x27;age&#x27;</span>],bins=<span class="number">10</span>,right=<span class="literal">True</span>)</span><br><span class="line">df[<span class="string">&#x27;capital-gain&#x27;</span>]=pd.cut(df[<span class="string">&#x27;capital-gain&#x27;</span>],bins=<span class="number">3</span>,right=<span class="literal">True</span>)</span><br><span class="line">df[<span class="string">&#x27;capital-loss&#x27;</span>]=pd.cut(df[<span class="string">&#x27;capital-loss&#x27;</span>],bins=<span class="number">3</span>,right=<span class="literal">True</span>)</span><br><span class="line">df[<span class="string">&#x27;hours-per-week&#x27;</span>]=pd.cut(df[<span class="string">&#x27;hours-per-week&#x27;</span>],bins=<span class="number">20</span>,right=<span class="literal">True</span>)</span><br><span class="line">df[<span class="string">&#x27;fnlwgt&#x27;</span>]=pd.cut(df[<span class="string">&#x27;fnlwgt&#x27;</span>],bins=<span class="number">20</span>,right=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>其他本身就已是离散型的特征就不需要处理了</p><p>继续划分训练集和测试集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#划分训练集和测试集,设置变量,为下面训练做准备</span></span><br><span class="line">train_data=df.sample(frac=<span class="number">0.7</span>, random_state=<span class="number">0</span>,axis=<span class="number">0</span>)</span><br><span class="line">test_data=df[~df.index.isin(train_data.index)]</span><br><span class="line"></span><br><span class="line">df_x = df.drop(columns=<span class="string">&quot;target&quot;</span>)</span><br><span class="line">df_y = df[<span class="string">&quot;target&quot;</span>].values</span><br><span class="line"></span><br><span class="line">trainX=train_data.drop(columns=<span class="string">&quot;target&quot;</span>)</span><br><span class="line">trainY=train_data[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">testX=test_data.drop(columns=<span class="string">&quot;target&quot;</span>)</span><br><span class="line">testY=test_data[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们需要实现朴树贝叶斯,以下代码来自他人之手,进行了完善修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveBayes</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, X_train, y_train</span>):</span></span><br><span class="line">        self.X_train = X_train  <span class="comment">#样本特征</span></span><br><span class="line">        self.y_train = y_train  <span class="comment">#样本类别</span></span><br><span class="line">        <span class="comment">#训练集样本中每个类别(二分类)的占比，即P(类别)，供后续使用</span></span><br><span class="line">        self.P_label = &#123;<span class="number">1</span>: np.mean(y_train.values), <span class="number">0</span>: <span class="number">1</span>-np.mean(y_train.values)&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#在数据集data中, 特征feature的值为value的样本所占比例</span></span><br><span class="line">    <span class="comment">#用于计算P(特征|类别)、P(特征)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFrequency</span>(<span class="params">self, data, feature, value</span>):</span></span><br><span class="line">        num = <span class="built_in">len</span>(data[data[feature]==value]) <span class="comment">#个数</span></span><br><span class="line">        <span class="keyword">return</span> num / (<span class="built_in">len</span>(data))</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X_test</span>):</span></span><br><span class="line">        self.prediction = [] <span class="comment">#预测类别</span></span><br><span class="line">        <span class="comment"># 遍历样本</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_test)):</span><br><span class="line">            x = X_test.iloc[i]      <span class="comment"># 第i个样本</span></span><br><span class="line">            P_feature_label0 = <span class="number">1</span>    <span class="comment"># P(特征|类别0)之和</span></span><br><span class="line">            P_feature_label1 = <span class="number">1</span>    <span class="comment"># P(特征|类别1)之和</span></span><br><span class="line">            P_feature = <span class="number">1</span>           <span class="comment"># P(特征)之和</span></span><br><span class="line">            <span class="comment"># 遍历特征</span></span><br><span class="line">            <span class="keyword">for</span> feature <span class="keyword">in</span> X_test.columns:</span><br><span class="line">                <span class="comment"># 分子项，P(特征|类别)</span></span><br><span class="line">                data0 = self.X_train[self.y_train.values==<span class="number">0</span>]  <span class="comment">#取类别为0的样本</span></span><br><span class="line">                P_feature_label0 *= self.getFrequency(data0, feature, x[feature]) <span class="comment">#计算P(feature|0)</span></span><br><span class="line"> </span><br><span class="line">                data1 = self.X_train[self.y_train.values==<span class="number">1</span>]  <span class="comment">#取类别为1的样本</span></span><br><span class="line">                P_feature_label1 *= self.getFrequency(data1, feature, x[feature]) <span class="comment">#计算P(feature|1)</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment"># 分母项，P(特征)</span></span><br><span class="line">                P_feature *= self.getFrequency(self.X_train, feature, x[feature])</span><br><span class="line"> </span><br><span class="line">            <span class="comment">#属于每个类别的概率</span></span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">25</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print (&#x27;...&#x27;)</span></span><br><span class="line">                print(<span class="string">&quot;预测第&quot;</span>,i,<span class="string">&quot;个&quot;</span>)</span><br><span class="line">                print(P_feature_label0)</span><br><span class="line">                print(P_feature_label1)</span><br><span class="line">            P_0 = (P_feature_label0*self.P_label[<span class="number">0</span>]) / P_feature</span><br><span class="line">            P_1 = (P_feature_label1 * self.P_label[<span class="number">1</span>]) / P_feature</span><br><span class="line">            <span class="comment">#选出大概率值对应的类别</span></span><br><span class="line">            self.prediction.append([<span class="number">1</span> <span class="keyword">if</span> P_1&gt;=P_0 <span class="keyword">else</span> <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> self.prediction</span><br><span class="line"><span class="comment">#from https://blog.csdn.net/weixin_39710249/article/details/111373540</span></span><br></pre></td></tr></table></figure><p>调用该类训练预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = NaiveBayes(trainX, trainY)  </span><br><span class="line">y_pre = model.predict(testX)    </span><br><span class="line">print(y_pre)     </span><br></pre></td></tr></table></figure><p>计算准确率:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">print(<span class="string">&quot;准确率：&quot;</span>,accuracy_score(y_pre, testY))</span><br></pre></td></tr></table></figure><p>计算auc值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#auc值</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line">auc_score = roc_auc_score(testY,y_pre)</span><br><span class="line">print(<span class="string">&quot;AUC值:&quot;</span>,auc_score)</span><br></pre></td></tr></table></figure><h1 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h1><p> <a href="https://github.com/HK560/MyMachineLearning/tree/main/experiment2">Github</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://blog.csdn.net/weixin_39710249/article/details/111373540">朴素贝叶斯代码_《机器学习》之 朴素贝叶斯原理及代码</a></li><li><a href="https://zhuanlan.zhihu.com/p/45835659">逻辑回归模型预测成年人收入水平</a></li><li><a href="https://blog.csdn.net/hohaizx/article/details/79084774">基于决策树和朴素贝叶斯算法对Adult数据集分类</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业学习实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Pixel4 玩机教程资源整理收集</title>
      <link href="/Piexl4Tools/"/>
      <url>/Piexl4Tools/</url>
      
        <content type="html"><![CDATA[<p>最近购入一台Pixel4，非常喜欢这个手机，在玩机过程中遇到了不少问题，因此建了个仓库收集整理了Pixel4相关资源教程，便于大家方便合理舒适地在国内使用Pixel4.<br>目前已在Github建设好仓库，慢慢更新完善咯~~</p><h1 id="仓库链接地址"><a href="#仓库链接地址" class="headerlink" title="仓库链接地址"></a><a href="https://github.com/HK560/Pixel4ToolsInChina">仓库链接地址</a></h1><h2 id="仓库说明"><a href="#仓库说明" class="headerlink" title="仓库说明"></a>仓库说明</h2><ul><li>本仓库搜集整理 2019年发布的Google Pixel 4 手机相关的工具组件模块教程等资源。便于在中国大陆更方便合理地使用Pixel4。</li><li>本文大部分资源教程为O版服务。请各位机主了解清楚自己的Pixel4是什么版本!</li><li><strong>注意仓库收录的资源适用于Pixel4,但不完全保证Pixel4XL也能够使用(虽然大体都可以互用的,有时候Pixel4XL的教程资源也能给Pixel4用)</strong></li><li><strong>大部分资源和教程来源于网络共享,本仓库仅作为指路导航</strong></li><li><strong>仓库仍在逐步建设更新完善</strong></li></ul><hr><h2 id="大致内容目录"><a href="#大致内容目录" class="headerlink" title="大致内容目录"></a>大致内容目录</h2><h5 id="放在前面："><a href="#放在前面：" class="headerlink" title="放在前面："></a>放在前面：</h5><ul><li>我想要拥有/拥有了一台 Pixel 4,我应该做些什么?</li><li>关于Pixel4你可能想知道的(官网，参数，故事，特性）</li><li><ul><li>查询我的 Pixel 4 是什么版本(查询IMEI)</li></ul></li><li>我是非运营商版本的O版(即能解锁BL)Pixel4,我想要获得更好的体验</li></ul><hr><h5 id="【教程搜集】-解锁BL-刷入Magisk-MotionSense模块电信模块"><a href="#【教程搜集】-解锁BL-刷入Magisk-MotionSense模块电信模块" class="headerlink" title="[【教程搜集】(解锁BL,刷入Magisk,MotionSense模块电信模块)"></a>[【<strong>教程搜集</strong>】(解锁BL,刷入Magisk,MotionSense模块电信模块)</h5><ul><li><p>解锁Bootloader(BL锁</p></li><li><p>通过Magisk 解锁使用root,Motion Sense电信VoLTE</p></li><li><ul><li>1.安装Magisk</li></ul></li><li><ul><li>2.安装并启用Magisk模块解锁雷达电信VoLTE</li></ul></li></ul><p>…….</p><hr><h5 id="【资源整理】-Magisk模块，驱动等）"><a href="#【资源整理】-Magisk模块，驱动等）" class="headerlink" title="【资源整理】(Magisk模块，驱动等）"></a>【<strong>资源整理</strong>】(Magisk模块，驱动等）</h5><ul><li>ADB 和 USB驱动</li><li>Magisk相关 （安装包 雷达电信模块）</li></ul><p>…….</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为ESP8266安装与配置ArduinoIDE</title>
      <link href="/configurationArduinoEsp8266/"/>
      <url>/configurationArduinoEsp8266/</url>
      
        <content type="html"><![CDATA[<h1 id="Arduino-IDE-安装-与-配置ESP8266开发环境"><a href="#Arduino-IDE-安装-与-配置ESP8266开发环境" class="headerlink" title="Arduino IDE 安装 与 配置ESP8266开发环境"></a>Arduino IDE 安装 与 配置ESP8266开发环境</h1><hr><blockquote><p>笔者因为正在开发的一个项目需要用到ArduinoIDE,所以便顺便写下一个文章记录安装和配置过程。</p></blockquote><hr><h2 id="ArduinoIDE下载与安装"><a href="#ArduinoIDE下载与安装" class="headerlink" title="ArduinoIDE下载与安装"></a>ArduinoIDE下载与安装</h2><p>官方网站软件下载地址:<br><a href="https://www.arduino.cc/en/software">https://www.arduino.cc/en/software</a><br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906121117.png" alt="选择下载"><br>选择适合自己的版本下载,本文章以windows安装版本示例</p><hr><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906134147.png" alt="选项"><br>进入安装界面,同意协议,选择路径,选项默认下一步即可</p><hr><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906134337.png"><br>安装过程中会弹出提示安装设备驱动,都点击安装即可</p><p>提示安装完成后即完成安装</p><hr><h2 id="为esp8266配置"><a href="#为esp8266配置" class="headerlink" title="为esp8266配置"></a>为esp8266配置</h2><p>启动Arduino IDE</p><p>弹出主界面后点击左上角的文件-首选项<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906161917.png"></p><hr><p>如图在箭头指向的框内输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;arduino.esp8266.com&#x2F;stable&#x2F;package_esp8266com_index.json</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906162134.png"></p><hr><p>可以在 网络 分页设置代理。因为服务器在国外,国内网络不一定能连接的上,推荐设置代理<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906162557.png"><br>完成后点“好”保存</p><hr><p>打开 开发板管理器<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906163130.png"><br>搜索esp8266 找到对应的平台版本 安装<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906163326.png"><br>等待下方的进度条读完即安装完成,如果超时或者安装失败请检查网络</p><hr><p>然后选择你对应的esp8266开发板即可<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906163541.png"></p><hr><p>在如同红框中配置波特率等设置<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210906163812.png"></p><hr><p>配置结束</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ESP8266_PCReader】使用ESP8266+OLED监控显示电脑硬件信息</title>
      <link href="/Aida64ForEsp8266/"/>
      <url>/Aida64ForEsp8266/</url>
      
        <content type="html"><![CDATA[<h2 id="这个项目是什么"><a href="#这个项目是什么" class="headerlink" title="这个项目是什么?"></a>这个项目是什么?</h2><p>本项目是关于使用ESP8266和OLED屏幕实现将电脑硬件状态信息数据读取并显示到OLED屏幕上且支持显示二值化图片/播放动画。<br>实现类似于高端主板上面的小屏幕功能,目前已实现实时显示电脑硬件状态,如温度、使用率、频率等。目前播放动画功能已开发完毕且发布。<br><a href="https://github.com/HK560/ESP8266DisplayPCHW" title="Github 项目地址">Github 项目地址</a></p><h2 id="关于这个项目"><a href="#关于这个项目" class="headerlink" title="关于这个项目"></a>关于这个项目</h2><p>受阿卡林的视频启发,本着兴趣和学习的目的做的第一个个人项目。本来对单片机也没什么了解,QT也是第一次使用边学边写,遇到了很多困难问题,不过好在最后目标功能都尽可能实现了。因为大二课比较多,开发时间比较碎片化,代码写的也比较难看,各位大能手下求饶。会认真听取建议批评的。</p><blockquote><p>本项目灵感来源于b站up主 会飞的阿卡林 所做视频</p></blockquote><p>阿卡林也是使用esp8266实现显示监控电脑硬件状态,不过与本项目区别在于:</p><ul><li>虽然都是通过aida64获取硬件信息,但阿卡林的方式是从aida64共享内存中获取信息。本项目是从aida64写入到注册表的硬件信息中获取。</li><li>阿卡林的开源上位机程序使用的是C#语言实现,而且支持播放动画图片的GUI版的上位机程序没有开源,本项目上位机程序通过QT C++开发实现了原项目大部分功能且开源。</li><li>阿卡林提供的下位机源码没有实现既可以播放动画又可以输出硬件信息</li></ul><hr><h2 id="使用条件和准备"><a href="#使用条件和准备" class="headerlink" title="使用条件和准备"></a>使用条件和准备</h2><p>硬件上需要:ESP8266和oled屏幕<br>若对单片机不了解推荐使用与我开发环境相同的:</p><ul><li>ESP8266 Node MCU Lua v3开发板(CH340串口芯片)</li><li>4PIN IIC 0.96寸OLED屏幕 128x64*</li></ul><p>某宝搜索上述关键词即可,陈本30块钱内</p><p>软件上需要:</p><ul><li>Aida64 并开启 “允许将检测数据写入注册表” 选项,且勾选列表内全部硬件信息监控</li><li>本项目的上位机程序 ESP8266 PC Reader</li><li>Arduino IDE 用于烧录下位机程序</li><li>对应的串口驱动程序(CH340驱动)</li></ul><hr><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="对于下位机ESP8266"><a href="#对于下位机ESP8266" class="headerlink" title="对于下位机ESP8266"></a>对于下位机ESP8266</h3><ol><li>   电脑安装对应的串口驱动</li><li>   将esp8266和oled屏幕连接好,并连接电脑。</li><li>   使用用arduino ide 将项目提供的.ino源码文件烧录进ESP8266(详细教程请自行网上搜索)。</li><li>   烧入成功启动后oled屏幕应该会显示有“waiting for singal”字样,表示烧入启动成功。</li></ol><h3 id="对于上位机PC"><a href="#对于上位机PC" class="headerlink" title="对于上位机PC"></a>对于上位机PC</h3><ol><li>请先自行安装Aida64 Extreme并激活(网上自行搜索教程)</li><li>打开aida64设置,按照如图所示勾选项目,保存。保证aida64后台运行以实时获取硬件信息。<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210923142025.png"></li><li>确保esp8266已连接电脑,运行项目提供的上位机程序ESP8266 PC Reader</li><li>如图步骤即可屏幕显示信息<br><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210923143652.png"></li><li>另外可以保存设置最小化等,请自行摸索</li></ol><hr><h2 id="关于显示图片-动画"><a href="#关于显示图片-动画" class="headerlink" title="关于显示图片/动画"></a>关于显示图片/动画</h2><ul><li>选择图片后程序会自动将图片二值化</li><li>只支持分辨率128x64的图片,若分辨率不对请自行裁剪</li><li>可以选择多张图片,若选择图片过多会程序会未响应读取加载较长时间,属于正常现象,加载完毕后便恢复正常</li><li>FPS设置框,表示一秒显示多少张图片,设置25则一秒内向单片机传输25张图片显示,设置0.5则表示每两秒传输显示一张图片。</li><li>如何播放动画?原理是将导入的图片按顺序播放出来,速度由FPS设置框决定。所以想要播放gif图片的话,需要将gif图分辨率设置为128x64,并将每帧图片切割出来按名字顺序排序,再在上位机程序里选择图片选择全部切割出来的帧图片即可。</li></ul><hr><h2 id="演示图"><a href="#演示图" class="headerlink" title="演示图"></a>演示图</h2><h3 id="上位机："><a href="#上位机：" class="headerlink" title="上位机："></a>上位机：</h3><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/20210922171958.png" alt="上位机" width="300" ><h3 id="下位机："><a href="#下位机：" class="headerlink" title="下位机："></a>下位机：</h3><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/esp8266show2.jpg" alt="示例2" width="300" align=center><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub@master/res/pic/esp8266Show1.jpg" alt="示例1" width="300"  align=center><ul><li>页面建设中</li></ul>]]></content>
      
      
      <categories>
          
          <category> QT项目 </category>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 项目 </tag>
            
            <tag> ESP8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地Hexo站点备份到Github上</title>
      <link href="/deployhexo/"/>
      <url>/deployhexo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、本地配置"><a href="#一、本地配置" class="headerlink" title="一、本地配置"></a>一、本地配置</h2><p>由于是在个人电脑上配置的hexo，部署也不方便，如果在另外一台机子上写博客，没有hexo的配置也不行，另一方面出于备份项目的目的，最好的办法是将本地hexo站点备份到Github上。<br>1.新建<code>hexo</code>文件夹存放分支工作目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo</span><br></pre></td></tr></table></figure><p>2.把你的GitHub的远程仓库克隆到<code>hexo</code>文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/HK560/hk560.github.io hexo</span><br></pre></td></tr></table></figure><p>3.删除除了版本管理的<code>.git</code>之外的所有文件和文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">rm -r *</span><br></pre></td></tr></table></figure><p>4.把要备份的文件复制到<code>hexo</code>目录</p><blockquote><p>scaffolds/<br>source/<br>themes/<br>.gitignore<br>_config.yml<br>package.json</p></blockquote><p>5.如果使用的主题是从Github克隆的，那么使用命令删除它的Git文件（以next主题为例）,否则无法将主题文件<code>push</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -R themes/next/.git*</span><br></pre></td></tr></table></figure><h2 id="二、github配置"><a href="#二、github配置" class="headerlink" title="二、github配置"></a>二、github配置</h2><p>1.github创建一个<code>hexo</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure><p>2.保存所有文件到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure><p>3.提交变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;创建hexo分支&quot;</span></span><br></pre></td></tr></table></figure><p>4.推送到github，并用<code>--set-upstream</code>与<code>origin</code>创建关联，将<code>hexo</code>设置为默认分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure><h2 id="三、合并管理"><a href="#三、合并管理" class="headerlink" title="三、合并管理"></a>三、合并管理</h2><p>现在有两个需要管理的文件夹，一个是<code>blog</code>，一个是<code>hexo</code>，但是每次发布文章的时候如果要提交两次就很失效率，<br>1.将本地<code>hexo</code>分支中的<code>.git</code>文件夹复制到<code>blog</code>根目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -a .git ../blog</span><br></pre></td></tr></table></figure><p>2.<code>master</code>分支的文件则由<code>hexo</code>管理，编辑<code>hexo</code>配置文件<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repo: https:&#x2F;&#x2F;github.com&#x2F;HK560&#x2F;hk560.github.io</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure><h2 id="四、发布文章"><a href="#四、发布文章" class="headerlink" title="四、发布文章"></a>四、发布文章</h2><p>1.新建文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.将相关更改推送到hexo分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;发表文章test&quot;</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure><p>3.将静态文件推送到master分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h2 id="五、使用的时候如何迁移"><a href="#五、使用的时候如何迁移" class="headerlink" title="五、使用的时候如何迁移"></a>五、使用的时候如何迁移</h2><p>1.将hexo分支克隆下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo https://github.com/HK560/hk560.github.io</span><br></pre></td></tr></table></figure><p>2.安装nodejs，设置好镜像站</p><p>3.安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>4.安装hexo依赖<br>cd到仓库根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>只不过每次发文章的时候，要输入用户名和密码。</p><blockquote><p>参考自：<a href="https://blog.csdn.net/weixin_44861399/article/details/104936907" title="将本地hexo站点备份到github上">将本地hexo站点备份到github上</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【个人经验】【入门向】如何买到一个属于自己的“好耳机”</title>
      <link href="/HowtoChooseHeadphones/"/>
      <url>/HowtoChooseHeadphones/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文可能涉及了一些专业术语，若是对这些专有名词不明白还请自己百度谷歌吧，，，知道这些知识对你选购耳机有很大帮助。<br>文中很多经验都是自己体会的，可能与客观事实不符欢迎指正，但是….听歌本来就是一件很玄学的事情….<br>全文字数在  5k左右，希望大家能慢慢看….虽然不大可能<br>还有些内容未完待更</p></blockquote><p>越来越多的人在听歌娱乐上有了追求，不过很多人以为买了个大牌子贵耳机就能享受到耳朵怀孕的感觉。其实那些往往对耳机圈没什么了解的人，买的第一副贵耳机自己都不大喜。</p><p>我这篇文章呢，主要是用来帮助那些，第一次想要认真提高听歌音质，而有一定钱来买装备的人。或者那些对听歌有需求却不知道该买什么怎么买的人。</p><p>适合预算在0~500左右的人看</p><p>适合不知道想买头戴式，入耳式，半入耳式，还是挂耳式的人</p><p>适合想盲狙耳机的人看（指没试听过直接买）</p><p>涉及到对蓝牙耳机的讨论</p><p>涉及到对大厂耳机的讨论</p><p>涉及到一些个人的建议和经验</p><p>首先吧，很多人以为要提高音质，就要提高耳机品质。的确耳机在提高音质方面占了很大方面，但不只是耳机，还有播放器，功放，线材，单元，很多方面都会影响最后你耳朵最后听到的声音。</p><p>总而言之，耳机对音质提高的确很重要，但是还有其他部分也在影响音质。</p><p>//</p><blockquote><p>这篇文章着重讨论耳机怎么选。</p></blockquote><p>//</p><p>首先你要买耳机了，那么你一定有钱了，而且有足够多的钱来入门。</p><p>我还是得讲一下价钱对耳机的影响</p><p>耳机的单元，一般有有动圈和动铁两种。不要觉得这些你没听过的名词烦，你若是要买个好耳机这些知识是必须知道的。</p><p>动圈单元成本比较便宜，在中低频发挥不错，大部分大耳(头戴式耳机)也是用动圈。</p><p>动铁的话单元很小，可以网上搜一搜图片。成本比动圈高，在中高音发挥不错。因为单元小，所以有些入耳式耳机可以塞下好几个动铁单元，当然价格也飞升。</p><p>大部分的低价耳机用的都是动圈，当然也可能有些有动铁的。有些耳机叫“圈铁”，意思是一个耳机里面动铁和动圈单元都有，这是存在的。比如小米的圈铁pro是三单元入耳式耳机(双动圈+一个动铁)价格130左右。</p><p>这并不意味着动铁耳机比动圈耳机贵所以动圈耳机好，这是错的。只是因为动铁成本高，所以一般的动铁耳机要贵于动圈耳机。</p><p>总结一下，一般动铁耳机比动圈耳机成本高，但动铁耳机不一定就比动圈耳机优秀或者适合你。两者的选择是需要看情况而判断的。详情看下文。</p><p>//</p><p>头戴式耳机，戴在头上的，普遍在同价位上，音质要弱于入耳式耳机那边的，500块钱一下我真的推荐别买头戴式了，老老实实入耳式吧，性价比高，也方便，便宜的头戴式还可能会碰到各种不舒服（夹头压耳什么的），而且后期不易进行diy（换线换耳塞）反正在这个预算下打心底不推荐。</p><p>入耳式耳机，半入耳式，挂耳式。普通的入耳式耳机应该是很多人的选择了。软塞入耳带着比较舒服。半入耳式的是硬塞子，戴久了耳朵痛，隔音也差。</p><p>我比较推荐挂耳式的耳机，首先这种耳机也是软塞入耳，而且一般腔体比较大，隔音要比普通入耳式好，而且是挂耳的，所以不太容易掉。现在挺流行这种设计的。</p><p>总而言之，500以下预算最好别买头戴式耳机，最好买挂耳式入耳耳机</p><p>谈到蓝牙耳机，耳机圈统一意见都是：要蓝牙不要音质，要音质不要蓝牙。有些很糟糕的蓝牙耳机，用的芯片糟糕，音质会变得特别糟糕，基本不能听。当然有些做得好得蓝牙耳机能够将音质减损做到很低，不过那个价格我寻思你也不太能接受。音质和无线两者不得兼，除非你真的有巨多钱而且不考虑性价比。</p><p>总而言之，为了提高性价比，不推荐500以下价位的买蓝牙耳机，不过真的有无线需求，我这边也有一些建议。后文会讲。</p><p>//</p><p>回到价格上，我将200块钱化为分水岭。</p><p>预算在0～200的其实不用太过纠结买什么耳机，，因为有一说一，音质都差不多，但并不是说买不到好的，只是……不如加点钱买个真正意义上的入门好耳机？当然如果你看完这篇文章，对那些耳机的数据参数都有了解了，你也能按照自己的听歌口味进行筛选出比较符合你的。</p><p>预算在200到500。那么可以认真选一款耳机了。可以开始分析了。</p><p>首先需要确定自己平时的听歌习惯，用什么平台播放，什么软件播放，在哪听，怎么听，听什么种类的歌。</p><p>上面这些个人习惯拿来作为选耳机参考都比较重要。</p><p>首先需要明确一个观念，价格贵的耳机不一定就能够在所有方面（高音低音声场解析分离等等）都能有非常好的表现，基本现在有丶名气的耳机都是有自身的特点和缺点的，不可能有完美的耳机。同价位下，一个好耳机应该专注于一个方面方向的提升，才能给听者带来更好的感受。例如有些耳机低音发挥的比较好，动次打次很爽，但可能在解析度方面就不行，会显得声音比较闷；而那些解析度很高的耳机可能低音就显得很薄，高音会非常刺耳。有得有失，但也正是因为每个耳机的调教方向不同，耳机圈才会那么活跃，一个好耳机往往需要调音师的大量心血才能诞生的。这也是为什么有些耳机成本不高，但却卖的那么贵。</p><p>说白了，那些主打没有短板的耳机其实就是什么方面都做不好。选对一个好耳机应该是要按照自己听歌习惯找到一个适合自己需求的耳机。</p><p>什么都适合听的耳机就是什么都不好听！</p><p>我猜大部分人都是听流行乐多，人声，电子乐。</p><p>我们就按这个听歌风格举例分析，排一下心中听歌风格的优先顺序，这里按照 流行人声&gt;电子乐&gt;交响乐。</p><p>//<br>首先是流行乐人声，人声的声音其实在人能听到的频段里面的中低频，也是耳机频响曲线图里面的中间偏左的部分，可以说是中低音部分。因此我们应该选一个耳机是能在中低频发挥出色的耳机。</p><p>但这是不够的，因为人声还要考虑一个解析度问题，你总不想听人声好像隔层膜一样闷闷的。而且大部分人对耳机好坏的判断也是解析度高不高。</p><p>所以要选一个中低频发挥好，解析度较高的耳机。</p><p>注意了，解析度太高并不好，太高往往会造成你能把歌手的一些声音的缺点都听出来了，或者是一些由录制问题产生的齿音等问题，相信我，有时候听得太清楚也不是好事。</p><p>接下来是电子乐，电子乐中其实也有很多分类，这里按低音电子乐。低音或重低音占了大部分，那么我们需要一个能在低音表现很好的耳机，这里还会涉及到“下潜”等一些名词来参考一个耳机的低频表现力，这里不做细讲。这里的耳机需求与上一个对听流行人声的耳机需求分析不重复，要求中低频着重要好。</p><p>交响乐，虽然优先级最后，但我还是在这里讲一下，交响乐对耳机的解析度要求很高，对耳机在全频段的表现都要求很高，而且声场要大，分离要好，让听着能听清楚每个乐器在哪，有一种被包围的感觉。不得不说要买一个能听交响乐的好耳机，投入的钱要非常多，几千才能入门。所以一般1k以下的价位就别想耳机能对交响乐有多好的表现吧….</p><p>按照举的例子分析，我们总结一下，根据举例的需求我们需要一个能在中低频表现好的，解析度稍微高一点的耳机，而声场，高音能多好就好。所以我们应该选择动圈耳机。</p><p>但我们必须知道，耳机不是完美的，可能你的需求中刚好就有冲突的，这需要你自己排一下优先顺序。我这边写几个根据我自己的经验，的几个冲突。</p><p>以下是互相冲突的</p><p>重低音——高解析</p><p>大声场——人声近（密）</p><p>高解析——高音控得住</p><p>….</p><p>只能说听耳机是一件很玄学的事情。</p><p>//</p><p>所以我们的需求中“中低频发挥好，解析度较高”是有一定冲突的。</p><p>然后再排一下需求优先级顺序，最终确定我要一个人声好的，解析度高的，尽量中低音表现好的耳机。</p><p>//</p><p>好了其实到这里我们就可以开始找耳机了。不过我这里再多插一句话。</p><p>其实吧，有些耳机diy程度很高，比如有些入耳式耳机能够更换线材，更换软塞。</p><p>其实更换线材对音质提高是有一定帮助的，软塞也是。用比较好的线材（升级线）比如什么单晶铜镀银，能够提高声音质感，耳机解析度，改变声音冷暖。sony的一个软塞（我们叫哥伦比亚套）能够将中频突出，人声变得厚实突出。</p><p>意思是说，我们其实能买一个本身就能在中低频表现好的耳机，然后通过diy更换升级线更换软塞等方式，将它的解析度提高，人声提前。</p><p>不过这需要你在买耳机本身的钱之外再加钱买升级线等。（升级线可不便宜哦，一般100以上）</p><p>这种选择方式适合一些拥有高定制能力的耳机和你有未来升级耳机的想法。</p><p>不过这种升级方式有时候是与耳机本身的设计理念背道而驰，本来调音师希望这个耳机在低音表现很好，结果你硬是把他往中高音改善，最后也只是吧耳机变得什么方面都不好，一个好耳机就应该做好它最擅长的事情。</p><p>//</p><p>决定好对耳机的需求后我们可以开始找耳机了。</p><p>有一说一，在非常不了解耳机圈的情况下，买耳机是非常危险的（这就是盲狙），即使是你已经清楚知道了自己的需求。</p><p>我非常不建议盲狙耳机，最好都是试听过再买。</p><p>如果你坚持要盲狙，那继续看吧。</p><p>我个人建议，在已经明确知道自己的需求之后，应该咨询对耳机圈非常了解的人（我不是啊别找我），比如去论坛问，去贴吧问，让他们根据你在这个价位下的需求推荐给你耳机型号。</p><p>当然别人推荐的东西不是立马就可以买了，有些人往往还是水军。知道了耳机型号之后，你就应该在网上搜搜这个型号耳机的评测。</p><p>网上的评测的确很多是水军的，但并不是不能看。你要看的是那些能够将这个耳机的特点缺点讲的十分详细的评测，最好是有同价位横向与其他耳机比较的。</p><p>某某说XX耳机好，解析高，声场大。这种评测是没有任何参考价值的。 </p><p>某某说XX耳机在这个价位下 ，解析在中高水平，低音表现在中低水平，比其他XX耳机在XX方面更好/较差。这种评测才是值得参考的。</p><p>看完推荐耳机的评测之后，确实了解到每款耳机的特点缺点，再根据你自己的实际喜好情况，就应该能选出来属于你的耳机了。</p><p>//</p><p>买前注意设备推力问题，有些耳机尤其是有动铁单元的耳机，欧姆比较大，普通手机什么的比较难推动，显得声音小，声音闷。耳机根本发挥不出来。</p><p>这个问题在买耳机之前看数据的时候就要注意了，一般官方也会放出数据来的，一般来说欧姆值越大你设备越难推动，一般手机推30欧以上的耳机就很吃力很吃力了（点名批评小米圈铁pro，32欧你让大家拿手机推？？），表现也很不好。</p><p>一般动圈耳机不会很难推动，一般是十几欧左右吧，手机能直接推动。</p><p>如果真的手机推不动，可以考虑购买dac线，这个这里不再详细阐述，属于前端的范围了，也是挺影响音质的，有兴趣可以自己网上搜。</p><p>耳机欧姆值也其实挺影响耳机音质和耳机上限的，这里也不再阐述，有兴趣自行百度。</p><p>//</p><p>再说说牌子问题吧，主流的大牌有铁三角 索尼 AKG 森海塞尔 飞利浦等。耳机也尽量买这几个牌子的，但是如果预算很低，就没必要买大牌了，可以看一些国产牌子，水月雨，KINERA什么的。</p><p>这里点名批评beats，大牌但是低性价比，典型的卖牌子卖颜值的耳机，耳机圈看买beats的人跟看憨批一样的…</p><p>不同厂子的调音风格也有些不一样，比如日厂的铁三角和索尼，在调音方面比较偏激，但也会有其他厂子耳机没有的独特魅力，比较适合日亚地区的曲子。（我个人全是铁三角的耳机）</p><p>森海塞尔 飞利浦那边跟偏欧美的风格，交响乐啊古典乐啥的都不错。</p><p>这里多说几句我现在用的耳机。</p><p>ATH -LS50 +升级线+哥套（适合听日系ACG乐，偏低音动次打次很爽，声场很大很爽，人声解析不太行，但换了升级线改善很多）</p><p>ATH-MSR7B+升级线+虑音棉（女毒女毒女毒男毒，外号陌生人妻，人声解析非常棒，声场也不错，致命缺点是低音）</p><p>你看我这两个耳机其实互相弥补了一定的缺点，我现在两个耳机轮流听很舒服。</p><p>这其实也说明了要想真正听音乐，得有好几副耳机才行，所以说玩音乐玩耳机烧钱啊啊啊。</p><p>//</p><p>以下是我个人的一些经验分享</p><p>其实想要入门耳机圈，没1k块钱太难了。</p><p>我现在找到的最优路线能够将，前端，耳放，线材，耳机解决——也要1k+</p><p>思路是这样的，前端设备（专业数字无损播放器）不单独买了，耳放（功放，解决耳机难推的问题）也不用买了，吧预算尽量投在耳机上。</p><p>买一个dac解码器，推力能多高就多高，我现在用的是ibasso的dc02，能够硬解dsd256,可以asio，可以手机用。</p><p>买耳机，买一个能更换线材的，我现在就是专买铁三角的a2dc的接口的耳机，一个升级线多个耳机用。然后尽量买两个耳机，把你的平时听歌的领域都覆盖掉，实在没钱就按我上文的优先级自己排来确认需求。</p><p>//</p><p>说到蓝牙，，有一说一，硬要说好的蓝牙耳机基本索尼家的wh-1000 xm3才能算入门，但是这玩意要1k多，而且音质比不上同价位其他的有线耳机。这里就不考虑了。</p><p>我要说的是另一种解决无线问题的方案：购买蓝牙升级线。</p><p>那些能够支持换线的耳机就很好办，直接换成蓝牙升级线就可以了，出门就用蓝牙线，不出门就换成普通升级线听。我现在就是这样的，而且有一说一，虽然音质肯定比不上有线，但如果选的对，比如有些蓝牙线是用高通什么8675的芯片，支持高通自家的无损传输，基本现在主流的用高通芯片的安卓机都能支持这个无损蓝牙传输，确实美滋滋。</p><p>剩下新买一对耳机的钱，一个耳机多用，能无线能有线，岂不美哉？</p><p>所以说，有一个能够支持拔插换线的耳机有多重要。</p><p>//</p><p>其实播放音乐时候的音量也会音响音质，一般来说，音量要稍高于你认为最舒适的音量时候，耳机才能发挥出最大效果，声音小会显得闷，声音太大会显得轰耳，最好的音量应该是让你感觉声音亮起来那种感觉……</p><p>//</p><p>安卓平台的专业音乐播放器app可以用 海贝音乐 能够软解dsd，而且设置也比较专业，如果你有dac线，可以用海贝音乐实现独占模式，音质会好很多很多。</p><p>电脑上可以用Foobar2000，也是专业播放器，配合一些插件，功能非常强大。</p><p>//</p><p>其实耳机线的头有很多种，平时见到最多的是3.5mm的立体声头，不过还有其他2.5 4.4的平衡头，这种是平衡头是走平衡线路传输的，和立体声头不一样，理论上这样的传输方式能把两声道的传输分开，保证传输的质量好于普通立体声输入。不过平衡头和立体声头听起来的韵味不同，看个人喜好。而且平衡头需要一个支持平衡输出的播放器前端，💰要多一些。</p><p>//定制升级线时候还会有个选择耳机头的问题，除了我上面说到的平衡头立体声头，还要注意是镀金镀银还是镀铑。</p><p>理论上，我们要选择一个导电效率最好的，但是也要注意容不容易被氧化脱落，镀的材质不同也会影响声音质感。铑比金稀有。镀铑的音色会薄一些尖一些，如果想要女毒可以镀铑，但是比镀金容易脱落。镀金是最稳妥的方案，综合来说最好。其实没有其他要求就镀金就行了。有些耳机头的出厂商不同，据说听起来也会有不同的感觉。至于是直头还是弯头看个人喜好即可。</p><p>//其他还没想到，待补充吧….这些经验够大家了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 电子产品 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATH-MSR7b——来自“陌生人妻”的一声低吟</title>
      <link href="/msr7b/"/>
      <url>/msr7b/</url>
      
        <content type="html"><![CDATA[<center>只要是稍微混过耳机圈的人基本都会听过 **“陌生人妻”**这个名字。<p>据说陌生人妻十分女毒，解析高声场大，在女毒调音方面基本没有谁了。</p><p>而陌生人妻也指的也就是铁三角的msr7了，但我这个文章要讲的是她的后辈，平衡升级版msr7b.</p><p>有幸，我手头得到一个<strong>msr7b</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-194924.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-194950.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-194929.jpg"></p><p><em>铁三角的新包装打都以白色为主调见怪不怪了</em></p><p><strong>这里要说的是msr7b中的b指的就是balanced，也就是说这个版本的msr7b走的是平衡路线，也支持平衡线</strong></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-190105.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-190308.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-194646.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-190446.jpg"></p><p><em>除了耳机主体外，附带了一个3.5mm立体声a2dc线，一个4.4mm平衡头a2dc线，还有个耳机袋，都可</em></p><p>耳机本体头梁用的人造皮(应该是吧)缝线什么的都很好，戴上很舒服，之前的msr7貌似会出现带久了氧化掉皮，这种现象貌似还没出现在msr7b上，应该是工艺改善了。</p><p>耳机头的工艺没话说，铁三角到这个价位的工艺都不会差的，金属，不过有个点要说的是logo和字的印刷用的是黑色的染料，这……真的很难看清楚logo和型号，上面的图大家也可以看出来这个……应该是铁三角故意的。这样显得陌生人妻也低调了不少，颇有神秘感。</p><p>耳罩很软，做工很好，非常舒服，改善了之前msr7压耳根的问题，把整个耳朵都包覆进去了。不过耳朵隔着单元就只有一层薄薄的布，耳大的人估计体验不会很好，陌生人妻出厂没有滤音棉，这个我稍后会提到。</p><hr><blockquote><p>下文我注重评价msr7和msr7b的区别。注意本文评测的主角是msr7b，为msr7的升级平衡版。“陌生人妻”是两者的共有外号，使用这个词时候我泛指两者。</p></blockquote><p>我的宿友恰有一个msr7，两个单论戴上的感受，msr7b要比msr7轻的多，不只是单元上的升级，重量也减轻了嗷，好评好评。</p><p>从外观上看，msr7貌似要比msr7b更小一圈，两者很容易辨认，msr7的logo非常明显。个人认为msr7b更能给人一种大耳的感觉，逼格一下就上来了。</p><p>msr7是3.5mm立体声输入，而msr7b采用的是自家的a2dc接口，最直观的就是一个有一条线，一个要分叉为两个线。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-190406.jpg"></p><p><em>但也就是如此msr7b支持平衡输入。</em></p><hr><p>陌生人妻得调音是偏女毒的，不得不说日产的耳机调音都比较偏激，但就是这样反而更有独特的味道。</p><p>初次听原厂的msr7(原厂线)，感觉声场挺大，解析很高，人声非常前，女声如同在耳边低喃，人声的高音也能充分体现出来。但是缺点也很明显，低音的量给的的确是太少了，更不要说下潜了……但绝对不比街边那些玩意差嗷。</p><p><strong>msr7我听的不多，因为一听到msr7b的……我就上头了。</strong></p><p><strong>msr7b原厂初开声，就把我麻了。</strong></p><p>我印象很深刻，我选的第一首是纯女声EGOIST的《原罪的灯》，女声一开我就被震撼到了……咂嘴声，换气声，黏黏腻腻，倾诉着一切，如同贴着你的背在耳边呼气低吟，那种只有asmr有的感觉在msr7b上完美重现。什么曲子在msr7b都散发出别样的光芒，我立马就中毒了。太毒了，女声太毒了。</p><p>我才想到“陌生人妻”真就如其名，只要中了她得毒，就难以摆脱，难以忘记，之前用的耳机都腿了色。陌生人妻的魅力就是如此，铁三角的调音造就了同价位无它能比的女毒耳机。</p><p>我立马就拿出了其他各种经典曲目挨个听了遍。王菲《匆匆那年》真的绝了，我突然觉得耳机已经足够好了，接下来应该是找好的嗓子好的音源了。因为陌生人妻的解析足够好，但因此也把一些歌手自身缺点放大，录制问题导致的缺点放大(如齿音)，齿音问题稍后谈。</p><p>msr7b相比msr7，进步不是一点点，正如她的“b”balanced，这次的调音并没有之前那么偏激，随着单元的升级，总体全方位都有进步。</p><p>低音虽然还是很少，但有所提升，可以满足大部分人听歌需求。声场进一步放大，分离非常好！可以听交响乐了都。音色相比msr7，没有那么冷和尖了。 msr7像是活泼小女生，那么msr7b更给人一种高不可攀的温柔女神，更有人妻那味了哈哈。</p><p>除了女声，其他也不是不能听，男声其实也蛮有感觉的，比较独特。得益于解析和分离声场的良好表现，大部分交响乐也能听也只是低音逊色了。不过说实在，人妻的高音有点刺了，不太适合。</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-190940.jpg"></p><p><em>为了进一步提高音质，我又花了一点💰，定制了八股镀银单晶铜3.5mm立体声头a2dc线。</em></p><p>换了升级线后，的确有进步，但也没有ls50那么恐怖，但是细细听下来，却像是女神更衣，整体声音质感更明显，显得有厚度了，解析更进一步，分离加强，听摇滚乐人声也能分离出来。因为我定制的是亚古德的头，对人声有一定(玄学)加成，把陌生人妻的独有刺感稍微压了压，男声听起来别有魅力，像是老大叔变小年轻的感觉……</p><p>这时候我差不多就把msr7b日常使用了，什么类型的曲子我都试了试。发现陌生人妻其实真的适合挺多类型的，纯乐，人声，摇滚，日轻，ACG都能听。除了某些真的高音疯了或者是堆低音的曲子。</p><p>不过听着听着我发现了一些未曾想过的问题。解析太高了，把很多从前都没有听出来的问题听出来了。这些问题，不是前端不是耳机问题，而是音源的问题，录制的问题，甚至是歌手的问题。</p><p>比如齿音严重这个问题，我现在用了陌生人妻才发现这个问题有多头疼，以前的耳机根本就不够好到吧齿音问题凸显出来。不得不说，我现在也体会到了传说中的高端耳机的“贵族病”（笑哭）</p><p>尤其是梁静茹那首《爱久见人心》，简直齿音爆炸杀了我吧，根本听不了。</p><p>这个问题没办法根本解决，只能靠调音师后期调整音源，或是以后科技发达了能从录制环节上解决吧。</p><p>就这个问题我咨询了群友，他们给了我一个意见——在耳机耳罩多加个虑音棉</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-194132.jpg"></p><p><em>虑音棉</em></p><p>这玩意据说能稍微降低一些高音刺，齿音严重的问题。</p><p>我稍微了解了一下这玩意，发现有些耳机其实就自带了这玩意，在单元和耳罩之间套上一个，但是陌生人妻是没有的，单元和耳朵就隔着薄薄的布。</p><p>所以把，我就好奇地整了一对，</p><p>额，说实话，套在耳套里面了，带上还蛮舒服的，不过对于音质的改善是有的，高音没那么刺了，但是！</p><p>感觉把人妻整体的音色都淡了下去，没有那么亮耳了，感觉有点得不偿失，而且改善齿音非常有限，总体来说我并不满意….</p><hr><p>说一下日常使用吧，</p><p>有一说一，不是无线的确很麻烦，而且是两条线。不过因为是可以插拔线的，挂在脖子上还行吧，，，当个装饰哈哈。</p><p>大耳漏音的问题，陌生人妻也逃不过，漏音很严重。反正自习室啥的地方就不要听了，老老实实入耳吧。</p><p>耳机梁那个人造皮感觉用久了会很容易掉，所以整了个耳机梁的保护套</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-194556.jpg"></p><p>反正带起来挺舒服的，这么贵重的耳机小小心保护啊</p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-195715.jpg"></p><p><em>整了个包，感觉不错</em></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-191028.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-190643.jpg"></p><p><em>陌生人妻外观还是很好看的</em></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-190559.jpg"></p><p><em>made in China 人妻都是在中国产的</em></p><p><img src="https://cdn.jsdelivr.net/gh/HK560/MyPicHub/res/pic/IMG-20191123-190458.jpg"></p><p>a2dc口，下面的滤网是调整单元内气压的</p><hr><p>总体来说，真的非常喜欢这个大耳，虽然不是无线非常不适合上街，但是为了追求音质嘛！音质永远是第一位。</p><p>陌生人妻不亏是烧友必听的调音耳机之一，女毒无敌。而且也对得起这个名字，对得起它的价格。很多细节上也能看出铁三角大厂对这款耳机倾了心。反正现在，我是不想用ls50啦啊哈哈哈。</p><p>msr7b的评测先到这吧，和它相处的时间还不长，希望以后能有更多发现！</p><p>接下来的日子请多多指教！</p></center><blockquote><p>原文章写于2019年</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 电子产品 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eclipse — Chouchou 歌词翻译</title>
      <link href="/eclipse/"/>
      <url>/eclipse/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-KCcivHQm" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1294889997" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><hr><center>It always wakes up at night<p>它总在深夜中明醒</p><p>And crawls around under my skin</p><p>在我的肌肤下延伸</p><p>I scratch myself again</p><p>我复又抓挠自己</p><p>Discoloration,distortion</p><p>「色变」「扭曲」</p><p>I groan in an anguished game</p><p>我在这个游戏中痛苦呻吟</p><p>No one knows who’s hiding there</p><p>可有人知道 谁 在那？</p><p>I disguise myself again</p><p>我复又伪装自己</p><p>Good night</p><p>“晚安吧”</p><p>Good night</p><p>“晚安吧”</p><p>I see the darkened sky</p><p>我注视着暗黑色的天空</p><p>Who is trying to steal my face?</p><p>“是谁在窥视我的脸庞？”</p><p>At the moment I’m scared,I can’t breath</p><p>此刻我焦虑惶恐 呼吸不能</p><p>Still I’m alive waiting for the day</p><p>我仍活着等待着那天的到来——</p><p>The day you will call my name</p><p>——你呼唤我的名字的那天</p><p>Who am I?</p><p>“我是谁呢？”</p><p>Imperfection,imitation</p><p>「瑕疵」「赝品」</p><p>I act in an foolish play</p><p>我把自己表现成一个愚笨之人</p><p>No one knows who’s innocent</p><p>可有人知道 谁 是无辜的？</p><p>I trapped myself again</p><p>我复又陷入困境</p><p>Who is trying to steal my face?</p><p>“是谁在窥视我的脸庞？”</p><p>At the moment I’m scared</p><p>此刻我焦虑惶恐</p><p>I can’t breath</p><p>呼吸不能</p><p>Still I’m alive waiting for the day</p><p>我仍活着等待着那天的到来——</p><p>The day you will call my name</p><p>——你呼唤我的名字的那天</p><p>Who am I</p><p>“我是谁？”</p><p>Take me out from this endless corridor</p><p>请把我带离这无尽的走廊</p><p>Who am I</p><p>“我是谁？”</p><p>I’m losing my eyes</p><p>我正在失去我的视线</p><p>I can’t see myself anymore</p><p>我再也看不见真正的自己</p><p>Why</p><p>为什么啊</p><p>Why do you shut me into this endless corridor</p><p>你为何要把我关禁在这无尽的走廊</p><p>Who am I</p><p>“我到底是谁？””</p><p>A ray of hope’s devoured by the dark again</p><p>一丝的希望再次被黑暗断绝</p><p>It always wakes up at night</p><p>——它总在深夜中明醒</p><p>And crawls around under my skin</p><p>——在我的肌肤下延伸</p><p>No one knows who’s hiding there</p><p>——可有人知道 谁 在那？</p><p>I scratch myself again</p><p>——我复又抓挠自己</p><p>Good night</p><p>——“晚安吧”</p><p>Good night</p><p>——“晚安吧”</p><p>And there’s no end in sight</p><p>无用去期盼尽头</p></center><hr><blockquote><p>翻译于2018年 已提交网易云该歌曲翻译</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
